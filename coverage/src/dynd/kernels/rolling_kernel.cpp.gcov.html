<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info.cleaned - src/dynd/kernels/rolling_kernel.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/dynd/kernels</a> - rolling_kernel.cpp<span style="font-size: 80%;"> (source / <a href="rolling_kernel.cpp.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info.cleaned</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">79</td>
            <td class="headerCovTableEntryLo">1.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-02-19</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntryLo">33.3 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2011-15 DyND Developers
<span class="lineNum">       3 </span>            : // BSD 2-Clause License, see LICENSE.txt
<span class="lineNum">       4 </span>            : //
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #include &lt;dynd/kernels/rolling_kernel.hpp&gt;
<span class="lineNum">       7 </span>            : #include &lt;dynd/types/var_dim_type.hpp&gt;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : using namespace std;
<a name="10"><span class="lineNum">      10 </span>            : using namespace dynd;</a>
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span><span class="lineNoCov">          0 : void nd::functional::strided_rolling_ck::single(char *dst, char *const *src)</span>
<span class="lineNum">      13 </span>            : {
<span class="lineNum">      14 </span><span class="lineNoCov">          0 :   kernel_prefix *nachild = get_child();</span>
<span class="lineNum">      15 </span><span class="lineNoCov">          0 :   kernel_prefix *wopchild = get_child(m_window_op_offset);</span>
<span class="lineNum">      16 </span><span class="lineNoCov">          0 :   kernel_strided_t nachild_fn = nachild-&gt;get_function&lt;kernel_strided_t&gt;();</span>
<span class="lineNum">      17 </span><span class="lineNoCov">          0 :   kernel_strided_t wopchild_fn = wopchild-&gt;get_function&lt;kernel_strided_t&gt;();</span>
<span class="lineNum">      18 </span>            :   // Fill in NA/NaN at the beginning
<span class="lineNum">      19 </span><span class="lineNoCov">          0 :   if (m_dim_size &gt; 0) {</span>
<span class="lineNum">      20 </span><span class="lineNoCov">          0 :     nachild_fn(nachild, dst, m_dst_stride, NULL, NULL, std::min(m_window_size - 1, m_dim_size));</span>
<span class="lineNum">      21 </span>            :   }
<span class="lineNum">      22 </span>            :   // Use stride trickery to do this as one strided call
<span class="lineNum">      23 </span><span class="lineNoCov">          0 :   if (m_dim_size &gt;= m_window_size) {</span>
<span class="lineNum">      24 </span><span class="lineNoCov">          0 :     wopchild_fn(wopchild, dst + m_dst_stride * (m_window_size - 1), m_dst_stride, src, &amp;m_src_stride,</span>
<span class="lineNum">      25 </span><span class="lineNoCov">          0 :                 m_dim_size - m_window_size + 1);</span>
<span class="lineNum">      26 </span>            :   }
<a name="27"><span class="lineNum">      27 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span><span class="lineNoCov">          0 : void nd::functional::var_rolling_ck::single(char *dst, char *const *src)</span>
<span class="lineNum">      30 </span>            : {
<span class="lineNum">      31 </span>            :   // Get the child ckernels
<span class="lineNum">      32 </span><span class="lineNoCov">          0 :   kernel_prefix *nachild = get_child();</span>
<span class="lineNum">      33 </span><span class="lineNoCov">          0 :   kernel_prefix *wopchild = get_child(m_window_op_offset);</span>
<span class="lineNum">      34 </span><span class="lineNoCov">          0 :   kernel_strided_t nachild_fn = nachild-&gt;get_function&lt;kernel_strided_t&gt;();</span>
<span class="lineNum">      35 </span><span class="lineNoCov">          0 :   kernel_strided_t wopchild_fn = wopchild-&gt;get_function&lt;kernel_strided_t&gt;();</span>
<span class="lineNum">      36 </span>            :   // Get pointers to the src and dst data
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :   ndt::var_dim_type::data_type *dst_dat = reinterpret_cast&lt;ndt::var_dim_type::data_type *&gt;(dst);</span>
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :   intptr_t dst_stride = reinterpret_cast&lt;const ndt::var_dim_type::metadata_type *&gt;(m_dst_meta)-&gt;stride;</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :   ndt::var_dim_type::data_type *src_dat = reinterpret_cast&lt;ndt::var_dim_type::data_type *&gt;(src[0]);</span>
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :   char *src_arr_ptr = src_dat-&gt;begin + m_src_offset;</span>
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :   intptr_t dim_size = src_dat-&gt;size;</span>
<span class="lineNum">      42 </span>            :   // Allocate the output data
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   dst_dat-&gt;begin = reinterpret_cast&lt;const ndt::var_dim_type::metadata_type *&gt;(m_dst_meta)-&gt;blockref-&gt;alloc(dim_size);</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   dst_dat-&gt;size = dim_size;</span>
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   char *dst_arr_ptr = dst_dat-&gt;begin;</span>
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :   // Fill in NA/NaN at the beginning
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   if (dim_size &gt; 0) {</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :     nachild_fn(nachild, dst_arr_ptr, dst_stride, NULL, NULL, std::min(m_window_size - 1, dim_size));</span>
<span class="lineNum">      52 </span>            :   }
<span class="lineNum">      53 </span>            :   // Use stride trickery to do this as one strided call
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   if (dim_size &gt;= m_window_size) {</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :     wopchild_fn(wopchild, dst_arr_ptr + dst_stride * (m_window_size - 1), dst_stride, &amp;src_arr_ptr, &amp;m_src_stride,</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :                 dim_size - m_window_size + 1);</span>
<span class="lineNum">      57 </span>            :   }
<span class="lineNum">      58 </span><span class="lineNoCov">          0 : }</span>
<a name="59"><span class="lineNum">      59 </span>            : </a>
<span class="lineNum">      60 </span>            : // TODO This should handle both strided and var cases
<span class="lineNum">      61 </span><span class="lineNoCov">          0 : void nd::functional::rolling_ck::instantiate(char *_static_data, char *data, kernel_builder *ckb,</span>
<span class="lineNum">      62 </span>            :                                              const ndt::type &amp;dst_tp, const char *dst_arrmeta, intptr_t nsrc,
<span class="lineNum">      63 </span>            :                                              const ndt::type *src_tp, const char *const *src_arrmeta,
<span class="lineNum">      64 </span>            :                                              kernel_request_t kernreq, intptr_t nkwd, const nd::array *kwds,
<span class="lineNum">      65 </span>            :                                              const std::map&lt;std::string, ndt::type&gt; &amp;tp_vars)
<span class="lineNum">      66 </span>            : {
<span class="lineNum">      67 </span>            :   typedef dynd::nd::functional::strided_rolling_ck self_type;
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   rolling_callable_data *static_data = *reinterpret_cast&lt;rolling_callable_data **&gt;(_static_data);</span>
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :   intptr_t root_ckb_offset = ckb-&gt;size();</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :   ckb-&gt;emplace_back&lt;self_type&gt;(kernreq);</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   self_type *self = ckb-&gt;get_at&lt;self_type&gt;(root_ckb_offset);</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   const base_callable *window_af = static_data-&gt;window_op.get();</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   ndt::type dst_el_tp, src_el_tp;</span>
<span class="lineNum">      75 </span>            :   const char *dst_el_arrmeta, *src_el_arrmeta;
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   if (!dst_tp.get_as_strided(dst_arrmeta, &amp;self-&gt;m_dim_size, &amp;self-&gt;m_dst_stride, &amp;dst_el_tp, &amp;dst_el_arrmeta)) {</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :     stringstream ss;</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :     ss &lt;&lt; &quot;rolling window ckernel: could not process type &quot; &lt;&lt; dst_tp;</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :     ss &lt;&lt; &quot; as a strided dimension&quot;;</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :     throw type_error(ss.str());</span>
<span class="lineNum">      81 </span>            :   }
<span class="lineNum">      82 </span>            :   intptr_t src_dim_size;
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   if (!src_tp[0].get_as_strided(src_arrmeta[0], &amp;src_dim_size, &amp;self-&gt;m_src_stride, &amp;src_el_tp, &amp;src_el_arrmeta)) {</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :     stringstream ss;</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :     ss &lt;&lt; &quot;rolling window ckernel: could not process type &quot; &lt;&lt; src_tp[0];</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     ss &lt;&lt; &quot; as a strided dimension&quot;;</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :     throw type_error(ss.str());</span>
<span class="lineNum">      88 </span>            :   }
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   if (src_dim_size != self-&gt;m_dim_size) {</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :     stringstream ss;</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :     ss &lt;&lt; &quot;rolling window ckernel: source dimension size &quot; &lt;&lt; src_dim_size &lt;&lt; &quot; for type &quot; &lt;&lt; src_tp[0]</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :        &lt;&lt; &quot; does not match dest dimension size &quot; &lt;&lt; self-&gt;m_dim_size &lt;&lt; &quot; for type &quot; &lt;&lt; dst_tp;</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :     throw type_error(ss.str());</span>
<span class="lineNum">      94 </span>            :   }
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   self-&gt;m_window_size = static_data-&gt;window_size;</span>
<span class="lineNum">      96 </span>            :   // Create the NA-filling child ckernel
<span class="lineNum">      97 </span>            :   // TODO: Need to fix this
<span class="lineNum">      98 </span>            :   //  ckb_offset = kernels::make_constant_value_assignment_ckernel(
<span class="lineNum">      99 </span>            :   //    ckb, ckb_offset, dst_el_tp, dst_el_arrmeta,
<span class="lineNum">     100 </span>            :   //  numeric_limits&lt;double&gt;::quiet_NaN(), kernel_request_strided, ectx);
<span class="lineNum">     101 </span>            :   // Re-retrieve the self pointer, because it may be at a new memory location
<span class="lineNum">     102 </span>            :   // now
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   self = reinterpret_cast&lt;kernel_builder *&gt;(ckb)-&gt;get_at&lt;self_type&gt;(root_ckb_offset);</span>
<span class="lineNum">     104 </span>            :   // Create the window op child ckernel
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   self-&gt;m_window_op_offset = ckb-&gt;size() - root_ckb_offset;</span>
<span class="lineNum">     106 </span>            :   // We construct array arrmeta for the window op ckernel to use,
<span class="lineNum">     107 </span>            :   // without actually creating an nd::array to hold it.
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   arrmeta_holder(ndt::make_fixed_dim(static_data-&gt;window_size, src_el_tp)).swap(self-&gt;m_src_winop_meta);</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   self-&gt;m_src_winop_meta.get_at&lt;fixed_dim_type_arrmeta&gt;(0)-&gt;dim_size = self-&gt;m_window_size;</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   self-&gt;m_src_winop_meta.get_at&lt;fixed_dim_type_arrmeta&gt;(0)-&gt;stride = self-&gt;m_src_stride;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   if (src_el_tp.get_arrmeta_size() &gt; 0) {</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     src_el_tp.extended()-&gt;arrmeta_copy_construct(self-&gt;m_src_winop_meta.get() + sizeof(fixed_dim_type_arrmeta),</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :                                                  src_el_arrmeta, intrusive_ptr&lt;memory_block_data&gt;());</span>
<span class="lineNum">     114 </span>            :   }
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   const char *src_winop_meta = self-&gt;m_src_winop_meta.get();</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   window_af-&gt;instantiate(const_cast&lt;char *&gt;(window_af-&gt;static_data()), data, ckb, dst_el_tp, dst_el_arrmeta, nsrc,</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :                          &amp;self-&gt;m_src_winop_meta.get_type(), &amp;src_winop_meta, kernel_request_strided, nkwd, kwds,</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :                          tp_vars);</span>
<a name="120"><span class="lineNum">     120 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span><span class="lineNoCov">          0 : void nd::functional::rolling_ck::resolve_dst_type(char *_static_data, char *data, ndt::type &amp;dst_tp,</span>
<span class="lineNum">     123 </span>            :                                                   intptr_t DYND_UNUSED(nsrc), const ndt::type *src_tp, intptr_t nkwd,
<span class="lineNum">     124 </span>            :                                                   const array *kwds, const std::map&lt;std::string, ndt::type&gt; &amp;tp_vars)
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : {
<span class="lineNum">     127 </span>            :   /*
<span class="lineNum">     128 </span>            :     if (nsrc != 1) {
<span class="lineNum">     129 </span>            :       stringstream ss;
<span class="lineNum">     130 </span>            :       ss &lt;&lt; &quot;Wrong number of arguments to rolling callable with prototype &quot;;
<span class="lineNum">     131 </span>            :       ss &lt;&lt; af_tp &lt;&lt; &quot;, got &quot; &lt;&lt; nsrc &lt;&lt; &quot; arguments&quot;;
<span class="lineNum">     132 </span>            :       throw invalid_argument(ss.str());
<span class="lineNum">     133 </span>            :     }
<span class="lineNum">     134 </span>            :   */
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   static_data_type *static_data = *reinterpret_cast&lt;static_data_type **&gt;(_static_data);</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   const base_callable *child_af = static_data-&gt;window_op.get();</span>
<span class="lineNum">     138 </span>            :   // First get the type for the child callable
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   ndt::type child_dst_tp;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   if (child_af-&gt;resolve_dst_type) {</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     ndt::type child_src_tp = ndt::make_fixed_dim(static_data-&gt;window_size, src_tp[0].get_type_at_dimension(NULL, 1));</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :     child_af-&gt;resolve_dst_type(const_cast&lt;char *&gt;(child_af-&gt;static_data()), data, child_dst_tp, 1, &amp;child_src_tp, nkwd,</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :                                kwds, tp_vars);</span>
<span class="lineNum">     144 </span>            :   }
<span class="lineNum">     145 </span>            :   else {
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :     child_dst_tp = static_data-&gt;window_op.get_type()-&gt;get_return_type();</span>
<span class="lineNum">     147 </span>            :   }
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   if (src_tp[0].get_id() == var_dim_id) {</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     dst_tp = ndt::var_dim_type::make(child_dst_tp);</span>
<span class="lineNum">     151 </span>            :   }
<span class="lineNum">     152 </span>            :   else {
<a name="153"><span class="lineNum">     153 </span><span class="lineNoCov">          0 :     dst_tp = ndt::make_fixed_dim(src_tp[0].get_dim_size(NULL, NULL), child_dst_tp);</span></a>
<span class="lineNum">     154 </span>            :   }
<span class="lineNum">     155 </span><span class="lineCov">          3 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info.cleaned - src/dynd/array.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">src/dynd</a> - array.cpp<span style="font-size: 80%;"> (source / <a href="array.cpp.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info.cleaned</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">341</td>
            <td class="headerCovTableEntry">622</td>
            <td class="headerCovTableEntryLo">54.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-02-19</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">28</td>
            <td class="headerCovTableEntry">46</td>
            <td class="headerCovTableEntryLo">60.9 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //</a>
<span class="lineNum">       2 </span>            : // Copyright (C) 2011-15 DyND Developers
<span class="lineNum">       3 </span>            : // BSD 2-Clause License, see LICENSE.txt
<span class="lineNum">       4 </span>            : //
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #include &lt;dynd/array.hpp&gt;
<span class="lineNum">       7 </span>            : #include &lt;dynd/array_iter.hpp&gt;
<span class="lineNum">       8 </span>            : #include &lt;dynd/callable.hpp&gt;
<span class="lineNum">       9 </span>            : #include &lt;dynd/func/assignment.hpp&gt;
<span class="lineNum">      10 </span>            : #include &lt;dynd/func/comparison.hpp&gt;
<span class="lineNum">      11 </span>            : #include &lt;dynd/func/elwise.hpp&gt;
<span class="lineNum">      12 </span>            : #include &lt;dynd/option.hpp&gt;
<span class="lineNum">      13 </span>            : #include &lt;dynd/types/var_dim_type.hpp&gt;
<span class="lineNum">      14 </span>            : #include &lt;dynd/types/fixed_dim_type.hpp&gt;
<span class="lineNum">      15 </span>            : #include &lt;dynd/types/tuple_type.hpp&gt;
<span class="lineNum">      16 </span>            : #include &lt;dynd/types/string_type.hpp&gt;
<span class="lineNum">      17 </span>            : #include &lt;dynd/types/bytes_type.hpp&gt;
<span class="lineNum">      18 </span>            : #include &lt;dynd/types/fixed_bytes_type.hpp&gt;
<span class="lineNum">      19 </span>            : #include &lt;dynd/types/type_type.hpp&gt;
<span class="lineNum">      20 </span>            : #include &lt;dynd/types/base_memory_type.hpp&gt;
<span class="lineNum">      21 </span>            : #include &lt;dynd/types/cuda_host_type.hpp&gt;
<span class="lineNum">      22 </span>            : #include &lt;dynd/types/cuda_device_type.hpp&gt;
<span class="lineNum">      23 </span>            : #include &lt;dynd/types/option_type.hpp&gt;
<span class="lineNum">      24 </span>            : #include &lt;dynd/kernels/assignment_kernels.hpp&gt;
<span class="lineNum">      25 </span>            : #include &lt;dynd/exceptions.hpp&gt;
<span class="lineNum">      26 </span>            : #include &lt;dynd/types/categorical_type.hpp&gt;
<span class="lineNum">      27 </span>            : #include &lt;dynd/memblock/memmap_memory_block.hpp&gt;
<span class="lineNum">      28 </span>            : #include &lt;dynd/view.hpp&gt;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : using namespace std;
<a name="31"><span class="lineNum">      31 </span>            : using namespace dynd;</a>
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span><span class="lineCov">         12 : nd::array nd::make_strided_array_from_data(const ndt::type &amp;uniform_tp, intptr_t ndim, const intptr_t *shape,</span>
<span class="lineNum">      34 </span>            :                                            const intptr_t *strides, int64_t access_flags, char *data_ptr,
<span class="lineNum">      35 </span>            :                                            const intrusive_ptr&lt;memory_block_data&gt; &amp;data_reference,
<span class="lineNum">      36 </span>            :                                            char **out_uniform_arrmeta)
<span class="lineNum">      37 </span>            : {
<span class="lineNum">      38 </span><span class="lineCov">         12 :   if (out_uniform_arrmeta == NULL &amp;&amp; !uniform_tp.is_builtin() &amp;&amp; uniform_tp.extended()-&gt;get_arrmeta_size() &gt; 0) {</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :     stringstream ss;</span>
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :     ss &lt;&lt; &quot;Cannot make a strided array with type &quot; &lt;&lt; uniform_tp &lt;&lt; &quot; from a preexisting data pointer&quot;;</span>
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :     throw runtime_error(ss.str());</span>
<span class="lineNum">      42 </span>            :   }
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span><span class="lineCov">         24 :   ndt::type array_type = ndt::make_fixed_dim(ndim, shape, uniform_tp);</span>
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            :   // Allocate the array arrmeta and data in one memory block
<span class="lineNum">      47 </span><span class="lineCov">         24 :   intrusive_ptr&lt;memory_block_data&gt; result = make_array_memory_block(array_type.get_arrmeta_size());</span>
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :   // Fill in the preamble arrmeta
<span class="lineNum">      50 </span><span class="lineCov">         12 :   array_preamble *ndo = reinterpret_cast&lt;array_preamble *&gt;(result.get());</span>
<span class="lineNum">      51 </span><span class="lineCov">         12 :   ndo-&gt;tp = array_type;</span>
<span class="lineNum">      52 </span><span class="lineCov">         12 :   ndo-&gt;data = data_ptr;</span>
<span class="lineNum">      53 </span><span class="lineCov">         12 :   ndo-&gt;owner = data_reference;</span>
<span class="lineNum">      54 </span><span class="lineCov">         12 :   ndo-&gt;flags = access_flags;</span>
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            :   // Fill in the array arrmeta with the shape and strides
<span class="lineNum">      57 </span><span class="lineCov">         12 :   fixed_dim_type_arrmeta *meta = reinterpret_cast&lt;fixed_dim_type_arrmeta *&gt;(ndo + 1);</span>
<span class="lineNum">      58 </span><span class="lineCov">         33 :   for (intptr_t i = 0; i &lt; ndim; ++i) {</span>
<span class="lineNum">      59 </span><span class="lineCov">         21 :     intptr_t dim_size = shape[i];</span>
<span class="lineNum">      60 </span><span class="lineCov">         21 :     meta[i].stride = dim_size &gt; 1 ? strides[i] : 0;</span>
<span class="lineNum">      61 </span><span class="lineCov">         21 :     meta[i].dim_size = dim_size;</span>
<span class="lineNum">      62 </span>            :   }
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :   // Return a pointer to the arrmeta for uniform_tp.
<span class="lineNum">      65 </span><span class="lineCov">         12 :   if (out_uniform_arrmeta != NULL) {</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :     *out_uniform_arrmeta = reinterpret_cast&lt;char *&gt;(meta + ndim);</span>
<span class="lineNum">      67 </span>            :   }
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span><span class="lineCov">         24 :   return nd::array(ndo, true);</span>
<span class="lineNum">      70 </span>            : }
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : /**
<span class="lineNum">      73 </span>            :  * Clones the arrmeta and swaps in a new type. The type must
<a name="74"><span class="lineNum">      74 </span>            :  * have identical arrmeta, but this function doesn't check that.</a>
<span class="lineNum">      75 </span>            :  */
<span class="lineNum">      76 </span><span class="lineCov">          4 : static nd::array make_array_clone_with_new_type(const nd::array &amp;n, const ndt::type &amp;new_dt)</span>
<span class="lineNum">      77 </span>            : {
<span class="lineNum">      78 </span>            :   nd::array result(reinterpret_cast&lt;array_preamble *&gt;(
<span class="lineNum">      79 </span><span class="lineCov">         12 :                        shallow_copy_array_memory_block(intrusive_ptr&lt;memory_block_data&gt;(n.get(), true)).get()),</span>
<span class="lineNum">      80 </span><span class="lineCov">          8 :                    true);</span>
<span class="lineNum">      81 </span><span class="lineCov">          4 :   array_preamble *preamble = result.get();</span>
<span class="lineNum">      82 </span>            :   // Swap in the type
<span class="lineNum">      83 </span><span class="lineCov">          4 :   preamble-&gt;tp = new_dt;</span>
<span class="lineNum">      84 </span><span class="lineCov">          4 :   return result;</span>
<span class="lineNum">      85 </span>            : }
<a name="86"><span class="lineNum">      86 </span>            : </a>
<span class="lineNum">      87 </span>            : namespace {
<span class="lineNum">      88 </span><span class="lineCov">          4 : static void as_storage_type(const ndt::type &amp;dt, intptr_t DYND_UNUSED(arrmeta_offset), void *DYND_UNUSED(self),</span>
<span class="lineNum">      89 </span>            :                             ndt::type &amp;out_transformed_tp, bool &amp;out_was_transformed)
<span class="lineNum">      90 </span>            : {
<span class="lineNum">      91 </span>            :   // If the type is a simple POD, switch it to a bytes type. Otherwise, keep it
<span class="lineNum">      92 </span>            :   // the same so that the arrmeta layout is identical.
<span class="lineNum">      93 </span><span class="lineCov">          4 :   if (dt.is_scalar() &amp;&amp; dt.get_id() != pointer_id) {</span>
<span class="lineNum">      94 </span><span class="lineCov">          2 :     const ndt::type &amp;storage_dt = dt.storage_type();</span>
<span class="lineNum">      95 </span><span class="lineCov">          2 :     if (storage_dt.is_builtin()) {</span>
<span class="lineNum">      96 </span><span class="lineCov">          1 :       out_transformed_tp = ndt::make_fixed_bytes(storage_dt.get_data_size(), storage_dt.get_data_alignment());</span>
<span class="lineNum">      97 </span><span class="lineCov">          1 :       out_was_transformed = true;</span>
<span class="lineNum">      98 </span>            :     }
<span class="lineNum">      99 </span><span class="lineCov">          1 :     else if (storage_dt.is_pod() &amp;&amp; storage_dt.extended()-&gt;get_arrmeta_size() == 0) {</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :       out_transformed_tp = ndt::make_fixed_bytes(storage_dt.get_data_size(), storage_dt.get_data_alignment());</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :       out_was_transformed = true;</span>
<span class="lineNum">     102 </span>            :     }
<span class="lineNum">     103 </span><span class="lineCov">          1 :     else if (storage_dt.get_id() == string_id) {</span>
<span class="lineNum">     104 </span>            :       out_transformed_tp =
<span class="lineNum">     105 </span><span class="lineCov">          1 :           ndt::bytes_type::make(static_cast&lt;const ndt::string_type *&gt;(storage_dt.extended())-&gt;get_target_alignment());</span>
<span class="lineNum">     106 </span><span class="lineCov">          1 :       out_was_transformed = true;</span>
<span class="lineNum">     107 </span>            :     }
<span class="lineNum">     108 </span>            :     else {
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :       if (dt.get_base_id() == expr_kind_id) {</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :         out_transformed_tp = storage_dt;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :         out_was_transformed = true;</span>
<span class="lineNum">     112 </span>            :       }
<span class="lineNum">     113 </span>            :       else {
<span class="lineNum">     114 </span>            :         // No transformation
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :         out_transformed_tp = dt;</span>
<span class="lineNum">     116 </span>            :       }
<span class="lineNum">     117 </span>            :     }
<span class="lineNum">     118 </span>            :   }
<span class="lineNum">     119 </span>            :   else {
<span class="lineNum">     120 </span><span class="lineCov">          2 :     dt.extended()-&gt;transform_child_types(&amp;as_storage_type, 0, NULL, out_transformed_tp, out_was_transformed);</span>
<span class="lineNum">     121 </span>            :   }
<span class="lineNum">     122 </span><span class="lineCov">          4 : }</span>
<a name="123"><span class="lineNum">     123 </span>            : } // anonymous namespace</a>
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span><span class="lineCov">          2 : nd::array nd::array::storage() const</span>
<span class="lineNum">     126 </span>            : {
<span class="lineNum">     127 </span><span class="lineCov">          4 :   ndt::type storage_dt = get_type();</span>
<span class="lineNum">     128 </span><span class="lineCov">          2 :   bool was_transformed = false;</span>
<span class="lineNum">     129 </span><span class="lineCov">          2 :   as_storage_type(get_type(), 0, NULL, storage_dt, was_transformed);</span>
<span class="lineNum">     130 </span><span class="lineCov">          2 :   if (was_transformed) {</span>
<span class="lineNum">     131 </span><span class="lineCov">          2 :     return make_array_clone_with_new_type(*this, storage_dt);</span>
<span class="lineNum">     132 </span>            :   }
<span class="lineNum">     133 </span>            :   else {
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">     135 </span>            :   }
<a name="136"><span class="lineNum">     136 </span>            : }</a>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span><span class="lineCov">     196170 : nd::array nd::array::at_array(intptr_t nindices, const irange *indices, bool collapse_leading) const</span>
<span class="lineNum">     139 </span>            : {
<span class="lineNum">     140 </span><span class="lineCov">     196170 :   if (!get_type().is_indexable()) {</span>
<span class="lineNum">     141 </span><span class="lineCov">          1 :     if (nindices != 0) {</span>
<span class="lineNum">     142 </span><span class="lineCov">          1 :       throw too_many_indices(get_type(), nindices, 0);</span>
<span class="lineNum">     143 </span>            :     }
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">     145 </span>            :   }
<span class="lineNum">     146 </span>            :   else {
<span class="lineNum">     147 </span><span class="lineCov">     392338 :     ndt::type this_dt = get()-&gt;tp;</span>
<span class="lineNum">     148 </span><span class="lineCov">     392318 :     ndt::type dt = get()-&gt;tp-&gt;apply_linear_index(nindices, indices, 0, this_dt, collapse_leading);</span>
<span class="lineNum">     149 </span><span class="lineCov">     392298 :     array result;</span>
<span class="lineNum">     150 </span><span class="lineCov">     196149 :     if (!dt.is_builtin()) {</span>
<span class="lineNum">     151 </span><span class="lineCov">        948 :       intrusive_ptr&lt;memory_block_data&gt; memblock = make_array_memory_block(dt.extended()-&gt;get_arrmeta_size());</span>
<span class="lineNum">     152 </span><span class="lineCov">        474 :       result = array(reinterpret_cast&lt;array_preamble *&gt;(memblock.get()), true);</span>
<span class="lineNum">     153 </span><span class="lineCov">        474 :       result.get()-&gt;tp = dt;</span>
<span class="lineNum">     154 </span>            :     }
<span class="lineNum">     155 </span>            :     else {
<span class="lineNum">     156 </span><span class="lineCov">     195675 :       result = array(reinterpret_cast&lt;array_preamble *&gt;(make_array_memory_block(0).get()), true);</span>
<span class="lineNum">     157 </span><span class="lineCov">     195675 :       result.get()-&gt;tp = dt;</span>
<span class="lineNum">     158 </span>            :     }
<span class="lineNum">     159 </span><span class="lineCov">     196149 :     result.get()-&gt;data = get()-&gt;data;</span>
<span class="lineNum">     160 </span><span class="lineCov">     196149 :     if (get()-&gt;owner) {</span>
<span class="lineNum">     161 </span><span class="lineCov">      25334 :       result.get()-&gt;owner = get()-&gt;owner;</span>
<span class="lineNum">     162 </span>            :     }
<span class="lineNum">     163 </span>            :     else {
<span class="lineNum">     164 </span>            :       // If the data reference is NULL, the data is embedded in the array itself
<span class="lineNum">     165 </span><span class="lineCov">     170815 :       result.get()-&gt;owner = get();</span>
<span class="lineNum">     166 </span>            :     }
<span class="lineNum">     167 </span><span class="lineCov">     980745 :     intptr_t offset = get()-&gt;tp-&gt;apply_linear_index(nindices, indices, get()-&gt;metadata(), dt, result.get()-&gt;metadata(),</span>
<span class="lineNum">     168 </span><span class="lineCov">     196149 :                                                     intrusive_ptr&lt;memory_block_data&gt;(get(), true), 0, this_dt,</span>
<span class="lineNum">     169 </span><span class="lineCov">     588447 :                                                     collapse_leading, &amp;result.get()-&gt;data, result.get()-&gt;owner);</span>
<span class="lineNum">     170 </span><span class="lineCov">     196139 :     result.get()-&gt;data += offset;</span>
<span class="lineNum">     171 </span><span class="lineCov">     196139 :     result.get()-&gt;flags = get()-&gt;flags;</span>
<span class="lineNum">     172 </span><span class="lineCov">     196139 :     return result;</span>
<span class="lineNum">     173 </span>            :   }
<a name="174"><span class="lineNum">     174 </span>            : }</a>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineCov">        762 : nd::array nd::array::assign(const array &amp;rhs, assign_error_mode error_mode) const</span>
<span class="lineNum">     177 </span>            : {
<span class="lineNum">     178 </span><span class="lineCov">        762 :   return nd::assign({rhs}, {{&quot;error_mode&quot;, error_mode}, {&quot;dst&quot;, *this}});</span>
<a name="179"><span class="lineNum">     179 </span>            : }</a>
<span class="lineNum">     180 </span>            : 
<a name="181"><span class="lineNum">     181 </span><span class="lineCov">        210 : nd::array nd::array::assign_na() const { return nd::assign_na({}, {{&quot;dst&quot;, *this}}); }</span></a>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineCov">         20 : void nd::array::flag_as_immutable()</span>
<span class="lineNum">     184 </span>            : {
<span class="lineNum">     185 </span>            :   // If it's already immutable, everything's ok
<span class="lineNum">     186 </span><span class="lineCov">         20 :   if ((get_flags() &amp; immutable_access_flag) != 0) {</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     188 </span>            :   }
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :   // Check that nobody else is peeking into our data
<span class="lineNum">     191 </span><span class="lineCov">         20 :   bool ok = true;</span>
<span class="lineNum">     192 </span><span class="lineCov">         20 :   if (intrusive_ptr&lt;array_preamble&gt;::get()-&gt;m_use_count != 1) {</span>
<span class="lineNum">     193 </span>            :     // More than one reference to the array itself
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :     ok = false;</span>
<span class="lineNum">     195 </span>            :   }
<span class="lineNum">     196 </span><span class="lineCov">         40 :   else if (get()-&gt;owner &amp;&amp; (get()-&gt;owner-&gt;m_use_count != 1 ||</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :                             !(get()-&gt;owner-&gt;m_type == fixed_size_pod_memory_block_type ||</span>
<span class="lineNum">     198 </span><span class="lineCov">         20 :                               get()-&gt;owner-&gt;m_type == pod_memory_block_type))) {</span>
<span class="lineNum">     199 </span>            :     // More than one reference to the array's data, or the reference is to
<span class="lineNum">     200 </span>            :     // something
<span class="lineNum">     201 </span>            :     // other than a memblock owning its data, such as an external memblock.
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     ok = false;</span>
<span class="lineNum">     203 </span>            :   }
<span class="lineNum">     204 </span><span class="lineCov">         20 :   else if (!get()-&gt;tp.is_builtin() &amp;&amp; !get()-&gt;tp-&gt;is_unique_data_owner(get()-&gt;metadata())) {</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     ok = false;</span>
<span class="lineNum">     206 </span>            :   }
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineCov">         20 :   if (ok) {</span>
<span class="lineNum">     209 </span>            :     // Finalize any allocated data in the arrmeta
<span class="lineNum">     210 </span><span class="lineCov">         20 :     if (!get()-&gt;tp.is_builtin()) {</span>
<span class="lineNum">     211 </span><span class="lineCov">         20 :       get()-&gt;tp-&gt;arrmeta_finalize_buffers(get()-&gt;metadata());</span>
<span class="lineNum">     212 </span>            :     }
<span class="lineNum">     213 </span>            :     // Clear the write flag, and set the immutable flag
<span class="lineNum">     214 </span><span class="lineCov">         20 :     get()-&gt;flags = (get()-&gt;flags &amp; ~(uint64_t)write_access_flag) | immutable_access_flag;</span>
<span class="lineNum">     215 </span>            :   }
<span class="lineNum">     216 </span>            :   else {
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     stringstream ss;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     ss &lt;&lt; &quot;Unable to flag array of type &quot; &lt;&lt; get_type() &lt;&lt; &quot; as immutable, because &quot;;</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     ss &lt;&lt; &quot;it does not uniquely own all of its data&quot;;</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     throw runtime_error(ss.str());</span>
<span class="lineNum">     221 </span>            :   }
<a name="222"><span class="lineNum">     222 </span>            : }</a>
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineCov">         84 : nd::array nd::array::p(const char *name) const</span>
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span><span class="lineCov">         84 :   if (!is_null()) {</span>
<span class="lineNum">     227 </span><span class="lineCov">         85 :     ndt::type dt = get_type();</span>
<span class="lineNum">     228 </span><span class="lineCov">         85 :     std::map&lt;std::string, nd::callable&gt; properties = dt.get_array_properties();</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span><span class="lineCov">         85 :     callable p = properties[name];</span>
<span class="lineNum">     231 </span><span class="lineCov">         84 :     if (!p.is_null()) {</span>
<span class="lineNum">     232 </span><span class="lineCov">        166 :       return p(eval()); // ToDo: Replace eval() here with an implicit cast</span>
<span class="lineNum">     233 </span>            :     }
<span class="lineNum">     234 </span>            :   }
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineCov">          2 :   stringstream ss;</span>
<span class="lineNum">     237 </span><span class="lineCov">          1 :   ss &lt;&lt; &quot;dynd array does not have property &quot; &lt;&lt; name;</span>
<span class="lineNum">     238 </span><span class="lineCov">          1 :   throw runtime_error(ss.str());</span>
<a name="239"><span class="lineNum">     239 </span>            : }</a>
<span class="lineNum">     240 </span>            : 
<a name="241"><span class="lineNum">     241 </span><span class="lineNoCov">          0 : nd::array nd::array::p(const std::string &amp;name) const { return p(name.c_str()); }</span></a>
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span><span class="lineCov">          1 : nd::callable nd::array::find_dynamic_function(const char *function_name) const</span>
<span class="lineNum">     244 </span>            : {
<span class="lineNum">     245 </span><span class="lineCov">          2 :   ndt::type dt = get_type();</span>
<span class="lineNum">     246 </span><span class="lineCov">          1 :   if (!dt.is_builtin()) {</span>
<span class="lineNum">     247 </span><span class="lineCov">          2 :     std::map&lt;std::string, callable&gt; functions = dt-&gt;get_dynamic_array_functions();</span>
<span class="lineNum">     248 </span><span class="lineCov">          2 :     return functions[function_name];</span>
<span class="lineNum">     249 </span>            :   }
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   stringstream ss;</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   ss &lt;&lt; &quot;dynd array does not have function &quot; &lt;&lt; function_name;</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   throw runtime_error(ss.str());</span>
<a name="254"><span class="lineNum">     254 </span>            : }</a>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineCov">        104 : nd::array nd::array::eval() const</span>
<span class="lineNum">     257 </span>            : {
<span class="lineNum">     258 </span><span class="lineCov">        104 :   const ndt::type &amp;current_tp = get_type();</span>
<span class="lineNum">     259 </span><span class="lineCov">        104 :   if (!current_tp.is_expression()) {</span>
<span class="lineNum">     260 </span><span class="lineCov">        104 :     return *this;</span>
<span class="lineNum">     261 </span>            :   }
<span class="lineNum">     262 </span>            :   else {
<span class="lineNum">     263 </span>            :     // Create a canonical type for the result
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     const ndt::type &amp;dt = current_tp.get_canonical_type();</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     array result(empty(dt));</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     if (dt.get_id() == fixed_dim_id) {</span>
<span class="lineNum">     267 </span>            :       // Reorder strides of output strided dimensions in a KEEPORDER fashion
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :       dt.extended&lt;ndt::fixed_dim_type&gt;()-&gt;reorder_default_constructed_strides(result.get()-&gt;metadata(), get_type(),</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :                                                                               get()-&gt;metadata());</span>
<span class="lineNum">     270 </span>            :     }
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :     result.assign(*this);</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">     273 </span>            :   }
<a name="274"><span class="lineNum">     274 </span>            : }</a>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span><span class="lineNoCov">          0 : nd::array nd::array::eval_immutable() const</span>
<span class="lineNum">     277 </span>            : {
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   const ndt::type &amp;current_tp = get_type();</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   if ((get_access_flags() &amp; immutable_access_flag) &amp;&amp; !current_tp.is_expression()) {</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">     281 </span>            :   }
<span class="lineNum">     282 </span>            :   else {
<span class="lineNum">     283 </span>            :     // Create a canonical type for the result
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     const ndt::type &amp;dt = current_tp.get_canonical_type();</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     array result(nd::empty(dt));</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     if (dt.get_id() == fixed_dim_id) {</span>
<span class="lineNum">     287 </span>            :       // Reorder strides of output strided dimensions in a KEEPORDER fashion
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :       dt.extended&lt;ndt::fixed_dim_type&gt;()-&gt;reorder_default_constructed_strides(result.get()-&gt;metadata(), get_type(),</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :                                                                               get()-&gt;metadata());</span>
<span class="lineNum">     290 </span>            :     }
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     result.assign(*this);</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     result.get()-&gt;flags = immutable_access_flag | read_access_flag;</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">     294 </span>            :   }
<a name="295"><span class="lineNum">     295 </span>            : }</a>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span><span class="lineNoCov">          0 : nd::array nd::array::eval_copy(uint32_t access_flags) const</span>
<span class="lineNum">     298 </span>            : {
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   const ndt::type &amp;current_tp = get_type();</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   const ndt::type &amp;dt = current_tp.get_canonical_type();</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   array result(nd::empty(dt));</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   if (dt.get_id() == fixed_dim_id) {</span>
<span class="lineNum">     303 </span>            :     // Reorder strides of output strided dimensions in a KEEPORDER fashion
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     dt.extended&lt;ndt::fixed_dim_type&gt;()-&gt;reorder_default_constructed_strides(result.get()-&gt;metadata(), get_type(),</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :                                                                             get()-&gt;metadata());</span>
<span class="lineNum">     306 </span>            :   }
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :   result.assign(*this);</span>
<span class="lineNum">     308 </span>            :   // If the access_flags are 0, use the defaults
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   access_flags = access_flags ? access_flags : (int32_t)nd::default_access_flags;</span>
<span class="lineNum">     310 </span>            :   // If the access_flags are just readonly, add immutable
<span class="lineNum">     311 </span>            :   // because we just created a unique instance
<span class="lineNum">     312 </span>            :   access_flags =
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :       (access_flags != nd::read_access_flag) ? access_flags : (nd::read_access_flag | nd::immutable_access_flag);</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   result.get()-&gt;flags = access_flags;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   return result;</span>
<a name="316"><span class="lineNum">     316 </span>            : }</a>
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineNoCov">          0 : nd::array nd::array::to_host() const</span>
<span class="lineNum">     319 </span>            : {
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   array result = empty(get_type().without_memory_type());</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :   result.assign(*this);</span>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">     324 </span>            : }
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            : #ifdef DYND_CUDA
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            : nd::array nd::array::to_cuda_host(unsigned int cuda_host_flags) const
<span class="lineNum">     329 </span>            : {
<span class="lineNum">     330 </span>            :   array result = empty(make_cuda_host(get_type().without_memory_type(), cuda_host_flags));
<span class="lineNum">     331 </span>            :   result.assign(*this);
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :   return result;
<span class="lineNum">     334 </span>            : }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : nd::array nd::array::to_cuda_device() const
<span class="lineNum">     337 </span>            : {
<span class="lineNum">     338 </span>            :   array result = empty(make_cuda_device(get_type().without_memory_type()));
<span class="lineNum">     339 </span>            :   result.assign(*this);
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :   return result;
<span class="lineNum">     342 </span>            : }
<span class="lineNum">     343 </span>            : 
<a name="344"><span class="lineNum">     344 </span>            : #endif // DYND_CUDA</a>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineCov">       1054 : bool nd::array::is_na() const</span>
<span class="lineNum">     347 </span>            : {
<span class="lineNum">     348 </span><span class="lineCov">       2108 :   ndt::type tp = get_type();</span>
<span class="lineNum">     349 </span><span class="lineCov">       1054 :   if (tp.get_id() == option_id) {</span>
<span class="lineNum">     350 </span><span class="lineCov">        235 :     return !tp.extended&lt;ndt::option_type&gt;()-&gt;is_avail(get()-&gt;metadata(), cdata(), &amp;eval::default_eval_context);</span>
<span class="lineNum">     351 </span>            :   }
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span><span class="lineCov">        819 :   return false;</span>
<a name="354"><span class="lineNum">     354 </span>            : }</a>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineCov">        324 : bool nd::array::equals_exact(const array &amp;rhs) const</span>
<span class="lineNum">     357 </span>            : {
<span class="lineNum">     358 </span><span class="lineCov">        324 :   if (get() == rhs.get()) {</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     360 </span>            :   }
<span class="lineNum">     361 </span><span class="lineCov">        324 :   else if (get_type() != rhs.get_type()) {</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     363 </span>            :   }
<span class="lineNum">     364 </span><span class="lineCov">        324 :   else if (get_ndim() == 0) {</span>
<span class="lineNum">     365 </span><span class="lineCov">        184 :     return (*this == rhs).as&lt;bool&gt;();</span>
<span class="lineNum">     366 </span>            :   }
<span class="lineNum">     367 </span><span class="lineCov">        140 :   else if (get_type().get_id() == var_dim_id) {</span>
<span class="lineNum">     368 </span>            :     // If there's a leading var dimension, convert it to strided and compare
<span class="lineNum">     369 </span>            :     // (Note: this is an inefficient hack)
<span class="lineNum">     370 </span><span class="lineCov">         16 :     ndt::type tp = ndt::make_fixed_dim(get_shape()[0], get_type().extended&lt;ndt::base_dim_type&gt;()-&gt;get_element_type());</span>
<span class="lineNum">     371 </span><span class="lineCov">          8 :     return nd::view(*this, tp).equals_exact(nd::view(rhs, tp));</span>
<span class="lineNum">     372 </span>            :   }
<span class="lineNum">     373 </span>            :   else {
<span class="lineNum">     374 </span>            :     // First compare the shape, to avoid triggering an exception in common cases
<span class="lineNum">     375 </span><span class="lineCov">        132 :     size_t ndim = get_ndim();</span>
<span class="lineNum">     376 </span><span class="lineCov">        132 :     if (ndim == 1 &amp;&amp; get_dim_size() == 0 &amp;&amp; rhs.get_dim_size() == 0) {</span>
<span class="lineNum">     377 </span><span class="lineCov">          1 :       return true;</span>
<span class="lineNum">     378 </span>            :     }
<span class="lineNum">     379 </span><span class="lineCov">        262 :     dimvector shape0(ndim), shape1(ndim);</span>
<span class="lineNum">     380 </span><span class="lineCov">        131 :     get_shape(shape0.get());</span>
<span class="lineNum">     381 </span><span class="lineCov">        131 :     rhs.get_shape(shape1.get());</span>
<span class="lineNum">     382 </span><span class="lineCov">        131 :     if (memcmp(shape0.get(), shape1.get(), ndim * sizeof(intptr_t)) != 0) {</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     384 </span>            :     }
<span class="lineNum">     385 </span>            :     try {
<span class="lineNum">     386 </span><span class="lineCov">        262 :       array_iter&lt;0, 2&gt; iter(*this, rhs);</span>
<span class="lineNum">     387 </span><span class="lineCov">        131 :       if (!iter.empty()) {</span>
<span class="lineNum">     388 </span><span class="lineCov">        759 :         do {</span>
<span class="lineNum">     389 </span><span class="lineCov">        759 :           const char *const src[2] = {iter.data&lt;0&gt;(), iter.data&lt;1&gt;()};</span>
<span class="lineNum">     390 </span><span class="lineCov">       2277 :           ndt::type tp[2] = {iter.get_uniform_dtype&lt;0&gt;(), iter.get_uniform_dtype&lt;1&gt;()};</span>
<span class="lineNum">     391 </span><span class="lineCov">        759 :           const char *arrmeta[2] = {iter.arrmeta&lt;0&gt;(), iter.arrmeta&lt;1&gt;()};</span>
<span class="lineNum">     392 </span><span class="lineCov">       1518 :           ndt::type dst_tp = ndt::make_type&lt;bool1&gt;();</span>
<span class="lineNum">     393 </span><span class="lineCov">       2277 :           if (not_equal::get()</span>
<span class="lineNum">     394 </span><span class="lineCov">       2277 :                   -&gt;call(dst_tp, 2, tp, arrmeta, const_cast&lt;char *const *&gt;(src), 0, NULL,</span>
<span class="lineNum">     395 </span>            :                          std::map&lt;std::string, ndt::type&gt;())
<span class="lineNum">     396 </span>            :                   .as&lt;bool&gt;()) {
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     398 </span>            :           }
<span class="lineNum">     399 </span>            :         } while (iter.next());
<span class="lineNum">     400 </span>            :       }
<span class="lineNum">     401 </span><span class="lineCov">        131 :       return true;</span>
<span class="lineNum">     402 </span>            :     }
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     catch (const broadcast_error &amp;) {</span>
<span class="lineNum">     404 </span>            :       // If there's a broadcast error in a variable-sized dimension, return
<span class="lineNum">     405 </span>            :       // false for it too
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     407 </span>            :     }
<span class="lineNum">     408 </span>            :   }
<a name="409"><span class="lineNum">     409 </span>            : }</a>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span><span class="lineCov">          1 : nd::array nd::array::cast(const ndt::type &amp;tp) const { return nd::assign({*this}, {{&quot;dst_tp&quot;, tp}}); }</span>
<span class="lineNum">     412 </span>            : 
<a name="413"><span class="lineNum">     413 </span>            : namespace {</a>
<span class="lineNum">     414 </span>            : struct cast_dtype_extra {
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   cast_dtype_extra(const ndt::type &amp;tp, size_t ru) : replacement_tp(tp), replace_ndim(ru), out_can_view_data(true) {}</span>
<span class="lineNum">     416 </span>            :   const ndt::type &amp;replacement_tp;
<span class="lineNum">     417 </span>            :   intptr_t replace_ndim;
<a name="418"><span class="lineNum">     418 </span>            :   bool out_can_view_data;</a>
<span class="lineNum">     419 </span>            : };
<span class="lineNum">     420 </span><span class="lineNoCov">          0 : static void cast_dtype(const ndt::type &amp;dt, intptr_t DYND_UNUSED(arrmeta_offset), void *extra,</span>
<span class="lineNum">     421 </span>            :                        ndt::type &amp;out_transformed_tp, bool &amp;out_was_transformed)
<span class="lineNum">     422 </span>            : {
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   cast_dtype_extra *e = reinterpret_cast&lt;cast_dtype_extra *&gt;(extra);</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   intptr_t replace_ndim = e-&gt;replace_ndim;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   if (dt.get_ndim() &gt; replace_ndim) {</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     dt.extended()-&gt;transform_child_types(&amp;cast_dtype, 0, extra, out_transformed_tp, out_was_transformed);</span>
<span class="lineNum">     427 </span>            :   }
<span class="lineNum">     428 </span>            :   else {
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     if (replace_ndim &gt; 0) {</span>
<span class="lineNum">     430 </span>            :       // If the dimension we're replacing doesn't change, then
<span class="lineNum">     431 </span>            :       // avoid creating the convert type at this level
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :       if (dt.get_id() == e-&gt;replacement_tp.get_id()) {</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :         bool can_keep_dim = false;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :         ndt::type child_dt, child_replacement_tp;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :         switch (dt.get_id()) {</span>
<span class="lineNum">     436 </span>            :         /*
<span class="lineNum">     437 </span>            :                 case cfixed_dim_id: {
<span class="lineNum">     438 </span>            :                   const cfixed_dim_type *dt_fdd =
<span class="lineNum">     439 </span>            :            dt.extended&lt;cfixed_dim_type&gt;();
<span class="lineNum">     440 </span>            :                   const cfixed_dim_type *r_fdd = static_cast&lt;const
<span class="lineNum">     441 </span>            :            cfixed_dim_type *&gt;(
<span class="lineNum">     442 </span>            :                       e-&gt;replacement_tp.extended());
<span class="lineNum">     443 </span>            :                   if (dt_fdd-&gt;get_fixed_dim_size() ==
<span class="lineNum">     444 </span>            :            r_fdd-&gt;get_fixed_dim_size() &amp;&amp;
<span class="lineNum">     445 </span>            :                       dt_fdd-&gt;get_fixed_stride() == r_fdd-&gt;get_fixed_stride()) {
<span class="lineNum">     446 </span>            :                     can_keep_dim = true;
<span class="lineNum">     447 </span>            :                     child_dt = dt_fdd-&gt;get_element_type();
<span class="lineNum">     448 </span>            :                     child_replacement_tp = r_fdd-&gt;get_element_type();
<span class="lineNum">     449 </span>            :                   }
<span class="lineNum">     450 </span>            :                 }
<span class="lineNum">     451 </span>            :         */
<span class="lineNum">     452 </span>            :         case var_dim_id: {
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :           const ndt::base_dim_type *dt_budd = dt.extended&lt;ndt::base_dim_type&gt;();</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :           const ndt::base_dim_type *r_budd = static_cast&lt;const ndt::base_dim_type *&gt;(e-&gt;replacement_tp.extended());</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :           can_keep_dim = true;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :           child_dt = dt_budd-&gt;get_element_type();</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :           child_replacement_tp = r_budd-&gt;get_element_type();</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     459 </span>            :         }
<span class="lineNum">     460 </span>            :         default:
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     462 </span>            :         }
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :         if (can_keep_dim) {</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :           cast_dtype_extra extra_child(child_replacement_tp, replace_ndim - 1);</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :           dt.extended()-&gt;transform_child_types(&amp;cast_dtype, 0, &amp;extra_child, out_transformed_tp, out_was_transformed);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">     467 </span>            :         }
<span class="lineNum">     468 </span>            :       }
<span class="lineNum">     469 </span>            :     }
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     throw std::runtime_error(&quot;trying to make convert_type&quot;);</span>
<span class="lineNum">     471 </span>            :     //    out_transformed_tp = ndt::convert_type::make(e-&gt;replacement_tp, dt);
<span class="lineNum">     472 </span>            :     // Only flag the transformation if this actually created a convert type
<span class="lineNum">     473 </span>            :     if (out_transformed_tp.extended() != e-&gt;replacement_tp.extended()) {
<span class="lineNum">     474 </span>            :       out_was_transformed = true;
<span class="lineNum">     475 </span>            :       e-&gt;out_can_view_data = false;
<span class="lineNum">     476 </span>            :     }
<span class="lineNum">     477 </span>            :   }
<span class="lineNum">     478 </span>            : }
<a name="479"><span class="lineNum">     479 </span>            : } // anonymous namespace</a>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineNoCov">          0 : nd::array nd::array::ucast(const ndt::type &amp;scalar_tp, intptr_t replace_ndim) const</span>
<span class="lineNum">     482 </span>            : {
<span class="lineNum">     483 </span>            :   // This creates a type which has a convert type for every scalar of different
<span class="lineNum">     484 </span>            :   // type.
<span class="lineNum">     485 </span>            :   // The result has the exact same arrmeta and data, so we just have to swap in
<span class="lineNum">     486 </span>            :   // the new
<span class="lineNum">     487 </span>            :   // type in a shallow copy.
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   ndt::type replaced_tp;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   bool was_transformed = false;</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   cast_dtype_extra extra(scalar_tp, replace_ndim);</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   cast_dtype(get_type(), 0, &amp;extra, replaced_tp, was_transformed);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   if (was_transformed) {</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     return make_array_clone_with_new_type(*this, replaced_tp);</span>
<span class="lineNum">     494 </span>            :   }
<span class="lineNum">     495 </span>            :   else {
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">     497 </span>            :   }
<a name="498"><span class="lineNum">     498 </span>            : }</a>
<span class="lineNum">     499 </span>            : 
<a name="500"><span class="lineNum">     500 </span><span class="lineCov">          1 : nd::array nd::array::view(const ndt::type &amp;tp) const { return nd::view(*this, tp); }</span></a>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineNoCov">          0 : nd::array nd::array::uview(const ndt::type &amp;uniform_dt, intptr_t replace_ndim) const</span>
<span class="lineNum">     503 </span>            : {
<span class="lineNum">     504 </span>            :   // Use the view function specifying to replace all dimensions
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :   return view(get_type().with_replaced_dtype(uniform_dt, replace_ndim));</span>
<span class="lineNum">     506 </span>            : }
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            : namespace {
<span class="lineNum">     509 </span>            : struct permute_dims_data {
<span class="lineNum">     510 </span>            :   intptr_t ndim, i;
<span class="lineNum">     511 </span>            :   const intptr_t *axes;
<a name="512"><span class="lineNum">     512 </span>            :   char *arrmeta;</a>
<span class="lineNum">     513 </span>            : };
<span class="lineNum">     514 </span><span class="lineCov">         13 : static void permute_type_dims(const ndt::type &amp;tp, intptr_t arrmeta_offset, void *extra, ndt::type &amp;out_transformed_tp,</span>
<span class="lineNum">     515 </span>            :                               bool &amp;out_was_transformed)
<span class="lineNum">     516 </span>            : {
<span class="lineNum">     517 </span><span class="lineCov">         13 :   permute_dims_data *pdd = reinterpret_cast&lt;permute_dims_data *&gt;(extra);</span>
<span class="lineNum">     518 </span><span class="lineCov">         13 :   intptr_t i = pdd-&gt;i;</span>
<span class="lineNum">     519 </span><span class="lineCov">         13 :   if (pdd-&gt;axes[i] == i) {</span>
<span class="lineNum">     520 </span>            :     // Stationary axis
<span class="lineNum">     521 </span><span class="lineCov">          4 :     if (pdd-&gt;i == pdd-&gt;ndim - 1) {</span>
<span class="lineNum">     522 </span>            :       // No more perm dimensions left, leave type as is
<span class="lineNum">     523 </span><span class="lineCov">          2 :       out_transformed_tp = tp;</span>
<span class="lineNum">     524 </span>            :     }
<span class="lineNum">     525 </span>            :     else {
<span class="lineNum">     526 </span><span class="lineCov">          2 :       if (tp.get_base_id() == dim_kind_id) {</span>
<span class="lineNum">     527 </span><span class="lineCov">          2 :         ++pdd-&gt;i;</span>
<span class="lineNum">     528 </span>            :       }
<span class="lineNum">     529 </span><span class="lineCov">          2 :       tp.extended()-&gt;transform_child_types(&amp;permute_type_dims, arrmeta_offset, extra, out_transformed_tp,</span>
<span class="lineNum">     530 </span><span class="lineCov">          2 :                                            out_was_transformed);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :       pdd-&gt;i = i;</span>
<span class="lineNum">     532 </span>            :     }
<span class="lineNum">     533 </span>            :   }
<span class="lineNum">     534 </span>            :   else {
<span class="lineNum">     535 </span>            :     // Find the smallest interval of mutually permuted axes
<span class="lineNum">     536 </span><span class="lineCov">          9 :     intptr_t max_i = pdd-&gt;axes[i], loop_i = i + 1;</span>
<span class="lineNum">     537 </span><span class="lineCov">         35 :     while (loop_i &lt;= max_i &amp;&amp; loop_i &lt; pdd-&gt;ndim) {</span>
<span class="lineNum">     538 </span><span class="lineCov">         13 :       if (pdd-&gt;axes[loop_i] &gt; max_i) {</span>
<span class="lineNum">     539 </span><span class="lineCov">          2 :         max_i = pdd-&gt;axes[loop_i];</span>
<span class="lineNum">     540 </span>            :       }
<span class="lineNum">     541 </span><span class="lineCov">         13 :       ++loop_i;</span>
<span class="lineNum">     542 </span>            :     }
<span class="lineNum">     543 </span>            :     // We must have enough consecutive strided dimensions
<span class="lineNum">     544 </span><span class="lineCov">          9 :     if (tp.get_strided_ndim() &lt; max_i - i + 1) {</span>
<span class="lineNum">     545 </span><span class="lineCov">          4 :       stringstream ss;</span>
<span class="lineNum">     546 </span><span class="lineCov">          2 :       ss &lt;&lt; &quot;Cannot permute non-strided dimensions in type &quot; &lt;&lt; tp;</span>
<span class="lineNum">     547 </span><span class="lineCov">          2 :       throw invalid_argument(ss.str());</span>
<span class="lineNum">     548 </span>            :     }
<span class="lineNum">     549 </span><span class="lineCov">         14 :     ndt::type subtp = tp.extended&lt;ndt::base_dim_type&gt;()-&gt;get_element_type();</span>
<span class="lineNum">     550 </span><span class="lineCov">         16 :     for (loop_i = i + 1; loop_i &lt;= max_i; ++loop_i) {</span>
<span class="lineNum">     551 </span><span class="lineCov">          9 :       subtp = subtp.extended&lt;ndt::base_dim_type&gt;()-&gt;get_element_type();</span>
<span class="lineNum">     552 </span>            :     }
<span class="lineNum">     553 </span><span class="lineCov">          7 :     intptr_t perm_ndim = max_i - i + 1;</span>
<span class="lineNum">     554 </span>            :     // If there are more permutation axes left, process the subtype
<span class="lineNum">     555 </span><span class="lineCov">          7 :     if (max_i &lt; pdd-&gt;ndim - 1) {</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :       pdd-&gt;i = max_i + 1;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :       tp.extended()-&gt;transform_child_types(&amp;permute_type_dims,</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :                                            arrmeta_offset + perm_ndim * sizeof(fixed_dim_type_arrmeta), extra, subtp,</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :                                            out_was_transformed);</span>
<span class="lineNum">     560 </span>            :     }
<span class="lineNum">     561 </span>            :     // Apply the permutation
<span class="lineNum">     562 </span><span class="lineCov">         14 :     dimvector shape(perm_ndim), permuted_shape(perm_ndim);</span>
<span class="lineNum">     563 </span><span class="lineCov">         14 :     shortvector&lt;size_stride_t&gt; perm_arrmeta(perm_ndim);</span>
<span class="lineNum">     564 </span><span class="lineCov">          7 :     size_stride_t *original_arrmeta = reinterpret_cast&lt;size_stride_t *&gt;(pdd-&gt;arrmeta + arrmeta_offset);</span>
<span class="lineNum">     565 </span><span class="lineCov">          7 :     memcpy(perm_arrmeta.get(), original_arrmeta, perm_ndim * sizeof(size_stride_t));</span>
<span class="lineNum">     566 </span><span class="lineCov">          7 :     tp.extended()-&gt;get_shape(max_i - i + 1, 0, shape.get(), NULL, NULL);</span>
<span class="lineNum">     567 </span><span class="lineCov">         23 :     for (loop_i = i; loop_i &lt;= max_i; ++loop_i) {</span>
<span class="lineNum">     568 </span><span class="lineCov">         16 :       intptr_t srcidx = pdd-&gt;axes[loop_i] - i;</span>
<span class="lineNum">     569 </span><span class="lineCov">         16 :       permuted_shape[loop_i - i] = shape[srcidx];</span>
<span class="lineNum">     570 </span><span class="lineCov">         16 :       original_arrmeta[loop_i - i] = perm_arrmeta[srcidx];</span>
<span class="lineNum">     571 </span>            :     }
<span class="lineNum">     572 </span><span class="lineCov">          7 :     out_transformed_tp = ndt::make_type(perm_ndim, permuted_shape.get(), subtp);</span>
<span class="lineNum">     573 </span><span class="lineCov">          7 :     out_was_transformed = true;</span>
<span class="lineNum">     574 </span>            :   }
<span class="lineNum">     575 </span><span class="lineCov">          9 : }</span>
<a name="576"><span class="lineNum">     576 </span>            : } // anonymous namespace</a>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineCov">         14 : nd::array nd::array::permute(intptr_t ndim, const intptr_t *axes) const</span>
<span class="lineNum">     579 </span>            : {
<span class="lineNum">     580 </span><span class="lineCov">         14 :   if (ndim &gt; get_ndim()) {</span>
<span class="lineNum">     581 </span><span class="lineCov">          2 :     stringstream ss;</span>
<span class="lineNum">     582 </span><span class="lineCov">          1 :     ss &lt;&lt; &quot;Too many dimensions provided for axis permutation, got &quot; &lt;&lt; ndim &lt;&lt; &quot; for type &quot; &lt;&lt; get_type();</span>
<span class="lineNum">     583 </span><span class="lineCov">          1 :     throw invalid_argument(ss.str());</span>
<span class="lineNum">     584 </span>            :   }
<span class="lineNum">     585 </span><span class="lineCov">         13 :   if (!is_valid_perm(ndim, axes)) {</span>
<span class="lineNum">     586 </span><span class="lineCov">          4 :     stringstream ss;</span>
<span class="lineNum">     587 </span><span class="lineCov">          2 :     ss &lt;&lt; &quot;Invalid permutation provided to dynd axis permute: [&quot;;</span>
<span class="lineNum">     588 </span><span class="lineCov">         12 :     for (intptr_t i = 0; i &lt; ndim; ++i) {</span>
<span class="lineNum">     589 </span><span class="lineCov">         10 :       ss &lt;&lt; axes[i] &lt;&lt; (i != ndim - 1 ? &quot; &quot; : &quot;&quot;);</span>
<span class="lineNum">     590 </span>            :     }
<span class="lineNum">     591 </span><span class="lineCov">          2 :     ss &lt;&lt; &quot;]&quot;;</span>
<span class="lineNum">     592 </span><span class="lineCov">          2 :     throw invalid_argument(ss.str());</span>
<span class="lineNum">     593 </span>            :   }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :   // Make a shallow copy of the arrmeta. When we permute the type,
<span class="lineNum">     596 </span>            :   // its arrmeta has identical structure, so we can fix it up
<span class="lineNum">     597 </span>            :   // while we're transforming the type.
<span class="lineNum">     598 </span>            :   nd::array res(reinterpret_cast&lt;array_preamble *&gt;(
<span class="lineNum">     599 </span><span class="lineCov">         33 :                     shallow_copy_array_memory_block(intrusive_ptr&lt;memory_block_data&gt;(get(), true)).get()),</span>
<span class="lineNum">     600 </span><span class="lineCov">         22 :                 true);</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span><span class="lineCov">         22 :   ndt::type transformed_tp;</span>
<span class="lineNum">     603 </span><span class="lineCov">         11 :   bool was_transformed = false;</span>
<span class="lineNum">     604 </span>            :   permute_dims_data pdd;
<span class="lineNum">     605 </span><span class="lineCov">         11 :   pdd.ndim = ndim;</span>
<span class="lineNum">     606 </span><span class="lineCov">         11 :   pdd.i = 0;</span>
<span class="lineNum">     607 </span><span class="lineCov">         11 :   pdd.axes = axes;</span>
<span class="lineNum">     608 </span><span class="lineCov">         11 :   pdd.arrmeta = res.get()-&gt;metadata();</span>
<span class="lineNum">     609 </span><span class="lineCov">         11 :   permute_type_dims(get_type(), 0, &amp;pdd, transformed_tp, was_transformed);</span>
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            :   // We can now substitute our transformed type into
<span class="lineNum">     612 </span>            :   // the result array
<span class="lineNum">     613 </span><span class="lineCov">          9 :   res.get()-&gt;tp = transformed_tp;</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineCov">         18 :   return res;</span>
<a name="616"><span class="lineNum">     616 </span>            : }</a>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineNoCov">          0 : nd::array nd::array::rotate(intptr_t to, intptr_t from) const</span>
<span class="lineNum">     619 </span>            : {
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :   if (from &lt; to) {</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     intptr_t ndim = to + 1;</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :     dimvector axes(ndim);</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :     for (intptr_t i = 0; i &lt; from; ++i) {</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :       axes[i] = i;</span>
<span class="lineNum">     625 </span>            :     }
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     for (intptr_t i = from; i &lt; to; ++i) {</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :       axes[i] = i + 1;</span>
<span class="lineNum">     628 </span>            :     }
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     axes[to] = from;</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     return permute(ndim, axes.get());</span>
<span class="lineNum">     632 </span>            :   }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :   if (from &gt; to) {</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :     intptr_t ndim = from + 1;</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     dimvector axes(ndim);</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     for (intptr_t i = 0; i &lt; to; ++i) {</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :       axes[i] = i;</span>
<span class="lineNum">     639 </span>            :     }
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     axes[to] = from;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     for (intptr_t i = to + 1; i &lt;= from; ++i) {</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :       axes[i] = i - 1;</span>
<span class="lineNum">     643 </span>            :     }
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     return permute(ndim, axes.get());</span>
<span class="lineNum">     646 </span>            :   }
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :   return *this;</span>
<a name="649"><span class="lineNum">     649 </span>            : }</a>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span><span class="lineNoCov">          0 : nd::array nd::array::transpose() const</span>
<span class="lineNum">     652 </span>            : {
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :   intptr_t ndim = get_ndim();</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :   dimvector axes(ndim);</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :   for (intptr_t i = 0; i &lt; ndim; ++i) {</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :     axes[i] = ndim - i - 1;</span>
<span class="lineNum">     657 </span>            :   }
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :   return permute(ndim, axes.get());</span>
<span class="lineNum">     660 </span>            : }
<span class="lineNum">     661 </span>            : 
<a name="662"><span class="lineNum">     662 </span>            : namespace {</a>
<span class="lineNum">     663 </span>            : struct replace_compatible_dtype_extra {
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :   replace_compatible_dtype_extra(const ndt::type &amp;tp, intptr_t replace_ndim_)</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :       : replacement_tp(tp), replace_ndim(replace_ndim_)</span>
<span class="lineNum">     666 </span>            :   {
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     668 </span>            :   const ndt::type &amp;replacement_tp;
<a name="669"><span class="lineNum">     669 </span>            :   intptr_t replace_ndim;</a>
<span class="lineNum">     670 </span>            : };
<span class="lineNum">     671 </span><span class="lineNoCov">          0 : static void replace_compatible_dtype(const ndt::type &amp;tp, intptr_t DYND_UNUSED(arrmeta_offset), void *extra,</span>
<span class="lineNum">     672 </span>            :                                      ndt::type &amp;out_transformed_tp, bool &amp;out_was_transformed)
<span class="lineNum">     673 </span>            : {
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   const replace_compatible_dtype_extra *e = reinterpret_cast&lt;const replace_compatible_dtype_extra *&gt;(extra);</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :   const ndt::type &amp;replacement_tp = e-&gt;replacement_tp;</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :   if (tp.get_ndim() == e-&gt;replace_ndim) {</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :     if (tp != replacement_tp) {</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :       if (!tp.data_layout_compatible_with(replacement_tp)) {</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :         stringstream ss;</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         ss &lt;&lt; &quot;The dynd type &quot; &lt;&lt; tp &lt;&lt; &quot; is not &quot;;</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :         ss &lt;&lt; &quot; data layout compatible with &quot; &lt;&lt; replacement_tp;</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :         ss &lt;&lt; &quot;, so a substitution cannot be made.&quot;;</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :         throw runtime_error(ss.str());</span>
<span class="lineNum">     684 </span>            :       }
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :       out_transformed_tp = replacement_tp;</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :       out_was_transformed = true;</span>
<span class="lineNum">     687 </span>            :     }
<span class="lineNum">     688 </span>            :   }
<span class="lineNum">     689 </span>            :   else {
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     tp.extended()-&gt;transform_child_types(&amp;replace_compatible_dtype, 0, extra, out_transformed_tp, out_was_transformed);</span>
<span class="lineNum">     691 </span>            :   }
<span class="lineNum">     692 </span><span class="lineNoCov">          0 : }</span>
<a name="693"><span class="lineNum">     693 </span>            : } // anonymous namespace</a>
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span><span class="lineNoCov">          0 : nd::array nd::array::replace_dtype(const ndt::type &amp;replacement_tp, intptr_t replace_ndim) const</span>
<span class="lineNum">     696 </span>            : {
<span class="lineNum">     697 </span>            :   // This creates a type which swaps in the new dtype for
<span class="lineNum">     698 </span>            :   // the existing one. It raises an error if the data layout
<span class="lineNum">     699 </span>            :   // is incompatible
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :   ndt::type replaced_tp;</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :   bool was_transformed = false;</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :   replace_compatible_dtype_extra extra(replacement_tp, replace_ndim);</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :   replace_compatible_dtype(get_type(), 0, &amp;extra, replaced_tp, was_transformed);</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   if (was_transformed) {</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     return make_array_clone_with_new_type(*this, replaced_tp);</span>
<span class="lineNum">     706 </span>            :   }
<span class="lineNum">     707 </span>            :   else {
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">     709 </span>            :   }
<a name="710"><span class="lineNum">     710 </span>            : }</a>
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span><span class="lineCov">         12 : nd::array nd::array::new_axis(intptr_t i, intptr_t new_ndim) const</span>
<span class="lineNum">     713 </span>            : {
<span class="lineNum">     714 </span><span class="lineCov">         24 :   ndt::type src_tp = get_type();</span>
<span class="lineNum">     715 </span><span class="lineCov">         24 :   ndt::type dst_tp = src_tp.with_new_axis(i, new_ndim);</span>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            :   // This is taken from view_concrete in view.cpp
<span class="lineNum">     718 </span><span class="lineCov">         12 :   nd::array res(reinterpret_cast&lt;array_preamble *&gt;(make_array_memory_block(dst_tp.get_arrmeta_size()).get()), true);</span>
<span class="lineNum">     719 </span><span class="lineCov">         12 :   res.get()-&gt;data = get()-&gt;data;</span>
<span class="lineNum">     720 </span><span class="lineCov">         12 :   if (!get()-&gt;owner) {</span>
<span class="lineNum">     721 </span><span class="lineCov">         12 :     res.get()-&gt;owner = get();</span>
<span class="lineNum">     722 </span>            :   }
<span class="lineNum">     723 </span>            :   else {
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :     res.get()-&gt;owner = get_data_memblock();</span>
<span class="lineNum">     725 </span>            :   }
<span class="lineNum">     726 </span><span class="lineCov">         12 :   res.get()-&gt;tp = dst_tp;</span>
<span class="lineNum">     727 </span><span class="lineCov">         12 :   res.get()-&gt;flags = get()-&gt;flags;</span>
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span><span class="lineCov">         12 :   char *src_arrmeta = const_cast&lt;char *&gt;(get()-&gt;metadata());</span>
<span class="lineNum">     730 </span><span class="lineCov">         12 :   char *dst_arrmeta = res.get()-&gt;metadata();</span>
<span class="lineNum">     731 </span><span class="lineCov">         23 :   for (intptr_t j = 0; j &lt; i; ++j) {</span>
<span class="lineNum">     732 </span><span class="lineCov">         33 :     dst_tp.extended&lt;ndt::base_dim_type&gt;()-&gt;arrmeta_copy_construct_onedim(dst_arrmeta, src_arrmeta,</span>
<span class="lineNum">     733 </span><span class="lineCov">         22 :                                                                          intrusive_ptr&lt;memory_block_data&gt;());</span>
<span class="lineNum">     734 </span><span class="lineCov">         11 :     src_tp = src_tp.get_type_at_dimension(&amp;src_arrmeta, 1);</span>
<span class="lineNum">     735 </span><span class="lineCov">         11 :     dst_tp = dst_tp.get_type_at_dimension(&amp;dst_arrmeta, 1);</span>
<span class="lineNum">     736 </span>            :   }
<span class="lineNum">     737 </span><span class="lineCov">         24 :   for (intptr_t j = 0; j &lt; new_ndim; ++j) {</span>
<span class="lineNum">     738 </span><span class="lineCov">         12 :     size_stride_t *smd = reinterpret_cast&lt;size_stride_t *&gt;(dst_arrmeta);</span>
<span class="lineNum">     739 </span><span class="lineCov">         12 :     smd-&gt;dim_size = 1;</span>
<span class="lineNum">     740 </span><span class="lineCov">         12 :     smd-&gt;stride = 0; // Should this not be zero?</span>
<span class="lineNum">     741 </span><span class="lineCov">         12 :     dst_tp = dst_tp.get_type_at_dimension(&amp;dst_arrmeta, 1);</span>
<span class="lineNum">     742 </span>            :   }
<span class="lineNum">     743 </span><span class="lineCov">         12 :   if (!dst_tp.is_builtin()) {</span>
<span class="lineNum">     744 </span><span class="lineCov">          8 :     dst_tp.extended()-&gt;arrmeta_copy_construct(dst_arrmeta, src_arrmeta, intrusive_ptr&lt;memory_block_data&gt;());</span>
<span class="lineNum">     745 </span>            :   }
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span><span class="lineCov">         24 :   return res;</span>
<span class="lineNum">     748 </span>            : }
<a name="749"><span class="lineNum">     749 </span>            : </a>
<span class="lineNum">     750 </span>            : namespace {
<span class="lineNum">     751 </span><span class="lineCov">          2 : static void view_scalar_types(const ndt::type &amp;dt, intptr_t DYND_UNUSED(arrmeta_offset), void *extra,</span>
<span class="lineNum">     752 </span>            :                               ndt::type &amp;out_transformed_tp, bool &amp;out_was_transformed)
<span class="lineNum">     753 </span>            : {
<span class="lineNum">     754 </span><span class="lineCov">          2 :   if (dt.is_scalar()) {</span>
<span class="lineNum">     755 </span><span class="lineCov">          2 :     const ndt::type *e = reinterpret_cast&lt;const ndt::type *&gt;(extra);</span>
<span class="lineNum">     756 </span>            :     // If things aren't simple, use a view_type
<span class="lineNum">     757 </span><span class="lineCov">          2 :     if (dt.get_base_id() == expr_kind_id || dt.get_data_size() != e-&gt;get_data_size() || !dt.is_pod() || !e-&gt;is_pod()) {</span>
<span class="lineNum">     758 </span>            :       // Some special cases that have the same memory layouts
<span class="lineNum">     759 </span><span class="lineCov">          2 :       switch (dt.get_id()) {</span>
<span class="lineNum">     760 </span>            :       case string_id:
<span class="lineNum">     761 </span>            :       case bytes_id:
<span class="lineNum">     762 </span><span class="lineCov">          2 :         switch (e-&gt;get_id()) {</span>
<span class="lineNum">     763 </span>            :         case string_id:
<span class="lineNum">     764 </span>            :         case bytes_id:
<span class="lineNum">     765 </span>            :           // All these types have the same data/arrmeta layout,
<span class="lineNum">     766 </span>            :           // allow a view whenever the alignment allows it
<span class="lineNum">     767 </span><span class="lineCov">          2 :           if (e-&gt;get_data_alignment() &lt;= dt.get_data_alignment()) {</span>
<span class="lineNum">     768 </span><span class="lineCov">          2 :             out_transformed_tp = *e;</span>
<span class="lineNum">     769 </span><span class="lineCov">          2 :             out_was_transformed = true;</span>
<span class="lineNum">     770 </span><span class="lineCov">          2 :             return;</span>
<span class="lineNum">     771 </span>            :           }
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     773 </span>            :         default:
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     775 </span>            :         }
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     777 </span>            :       default:
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     779 </span>            :       }
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :       throw std::runtime_error(&quot;creating a view_type&quot;);</span>
<span class="lineNum">     781 </span>            :       //      out_transformed_tp = ndt::view_type::make(*e, dt);
<span class="lineNum">     782 </span>            :       out_was_transformed = true;
<span class="lineNum">     783 </span>            :     }
<span class="lineNum">     784 </span>            :     else {
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :       out_transformed_tp = *e;</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :       if (dt != *e) {</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :         out_was_transformed = true;</span>
<span class="lineNum">     788 </span>            :       }
<span class="lineNum">     789 </span>            :     }
<span class="lineNum">     790 </span>            :   }
<span class="lineNum">     791 </span>            :   else {
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :     dt.extended()-&gt;transform_child_types(&amp;view_scalar_types, 0, extra, out_transformed_tp, out_was_transformed);</span>
<span class="lineNum">     793 </span>            :   }
<span class="lineNum">     794 </span>            : }
<a name="795"><span class="lineNum">     795 </span>            : } // anonymous namespace</a>
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span><span class="lineCov">          2 : nd::array nd::array::view_scalars(const ndt::type &amp;scalar_tp) const</span>
<span class="lineNum">     798 </span>            : {
<span class="lineNum">     799 </span><span class="lineCov">          2 :   const ndt::type &amp;array_type = get_type();</span>
<span class="lineNum">     800 </span><span class="lineCov">          2 :   size_t uniform_ndim = array_type.get_ndim();</span>
<span class="lineNum">     801 </span>            :   // First check if we're dealing with a simple one dimensional block of memory
<span class="lineNum">     802 </span>            :   // we can reinterpret
<span class="lineNum">     803 </span>            :   // at will.
<span class="lineNum">     804 </span><span class="lineCov">          2 :   if (uniform_ndim == 1 &amp;&amp; array_type.get_id() == fixed_dim_id) {</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     const ndt::fixed_dim_type *sad = array_type.extended&lt;ndt::fixed_dim_type&gt;();</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     const fixed_dim_type_arrmeta *md = reinterpret_cast&lt;const fixed_dim_type_arrmeta *&gt;(get()-&gt;metadata());</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     const ndt::type &amp;edt = sad-&gt;get_element_type();</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :     if (edt.is_pod() &amp;&amp; (intptr_t)edt.get_data_size() == md-&gt;stride &amp;&amp;</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         sad-&gt;get_element_type().get_base_id() != expr_kind_id) {</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :       intptr_t nbytes = md-&gt;dim_size * edt.get_data_size();</span>
<span class="lineNum">     811 </span>            :       // Make sure the element size divides into the # of bytes
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :       if (nbytes % scalar_tp.get_data_size() != 0) {</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         std::stringstream ss;</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :         ss &lt;&lt; &quot;cannot view array with &quot; &lt;&lt; nbytes &lt;&lt; &quot; bytes as type &quot;;</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :         ss &lt;&lt; scalar_tp &lt;&lt; &quot;, because its element size &quot; &lt;&lt; scalar_tp.get_data_size();</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :         ss &lt;&lt; &quot; doesn't divide evenly into the total array size &quot; &lt;&lt; nbytes;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :         throw std::runtime_error(ss.str());</span>
<span class="lineNum">     818 </span>            :       }
<span class="lineNum">     819 </span>            :       // Create the result array, adjusting the type if the data isn't aligned
<span class="lineNum">     820 </span>            :       // correctly
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :       char *data_ptr = get()-&gt;data;</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :       ndt::type result_tp;</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :       intptr_t dim_size = nbytes / scalar_tp.get_data_size();</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :       if ((((uintptr_t)data_ptr) &amp; (scalar_tp.get_data_alignment() - 1)) == 0) {</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :         result_tp = ndt::make_fixed_dim(dim_size, scalar_tp);</span>
<span class="lineNum">     826 </span>            :       }
<span class="lineNum">     827 </span>            :       else {
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :         throw std::runtime_error(&quot;creating an unaligned type&quot;);</span>
<span class="lineNum">     829 </span>            :         //        result_tp = ndt::make_fixed_dim(dim_size, make_unaligned(scalar_tp));
<span class="lineNum">     830 </span>            :       }
<span class="lineNum">     831 </span>            :       array result(
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :           reinterpret_cast&lt;array_preamble *&gt;(make_array_memory_block(result_tp.extended()-&gt;get_arrmeta_size()).get()),</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :           true);</span>
<span class="lineNum">     834 </span>            :       // Copy all the array arrmeta fields
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :       result.get()-&gt;data = get()-&gt;data;</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :       if (get()-&gt;owner) {</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :         result.get()-&gt;owner = get()-&gt;owner;</span>
<span class="lineNum">     838 </span>            :       }
<span class="lineNum">     839 </span>            :       else {
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :         result.get()-&gt;owner = intrusive_ptr&lt;array_preamble&gt;::get();</span>
<span class="lineNum">     841 </span>            :       }
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :       result.get()-&gt;tp = result_tp;</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :       result.get()-&gt;flags = get()-&gt;flags;</span>
<span class="lineNum">     844 </span>            :       // The result has one strided ndarray field
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :       fixed_dim_type_arrmeta *result_md = reinterpret_cast&lt;fixed_dim_type_arrmeta *&gt;(result.get()-&gt;metadata());</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :       result_md-&gt;dim_size = dim_size;</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :       result_md-&gt;stride = scalar_tp.get_data_size();</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :       return result;</span>
<span class="lineNum">     849 </span>            :     }
<span class="lineNum">     850 </span>            :   }
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            :   // Transform the scalars into view types
<span class="lineNum">     853 </span><span class="lineCov">          4 :   ndt::type viewed_tp;</span>
<span class="lineNum">     854 </span><span class="lineCov">          2 :   bool was_transformed = false;</span>
<span class="lineNum">     855 </span><span class="lineCov">          2 :   view_scalar_types(get_type(), 0, const_cast&lt;void *&gt;(reinterpret_cast&lt;const void *&gt;(&amp;scalar_tp)), viewed_tp,</span>
<span class="lineNum">     856 </span><span class="lineCov">          2 :                     was_transformed);</span>
<span class="lineNum">     857 </span><span class="lineCov">          2 :   return make_array_clone_with_new_type(*this, viewed_tp);</span>
<a name="858"><span class="lineNum">     858 </span>            : }</a>
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span><span class="lineNoCov">          0 : void nd::array::debug_print(std::ostream &amp;o, const std::string &amp;indent) const</span>
<span class="lineNum">     861 </span>            : {
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :   o &lt;&lt; indent &lt;&lt; &quot;------ array\n&quot;;</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :   if (intrusive_ptr&lt;array_preamble&gt;::get()) {</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     const array_preamble *ndo = get();</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     o &lt;&lt; &quot; address: &quot; &lt;&lt; (void *)intrusive_ptr&lt;array_preamble&gt;::get() &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :     o &lt;&lt; &quot; refcount: &quot; &lt;&lt; static_cast&lt;long&gt;(ndo-&gt;m_use_count) &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     o &lt;&lt; &quot; type:\n&quot;;</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     o &lt;&lt; &quot;  pointer: &quot; &lt;&lt; (void *)ndo-&gt;tp.extended() &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     o &lt;&lt; &quot;  type: &quot; &lt;&lt; get_type() &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :     if (!get_type().is_builtin()) {</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :       o &lt;&lt; &quot;  type refcount: &quot; &lt;&lt; get_type().extended()-&gt;get_use_count() &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     872 </span>            :     }
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :     o &lt;&lt; &quot; arrmeta:\n&quot;;</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :     o &lt;&lt; &quot;  flags: &quot; &lt;&lt; ndo-&gt;flags &lt;&lt; &quot; (&quot;;</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     if (ndo-&gt;flags &amp; read_access_flag)</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :       o &lt;&lt; &quot;read_access &quot;;</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     if (ndo-&gt;flags &amp; write_access_flag)</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :       o &lt;&lt; &quot;write_access &quot;;</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     if (ndo-&gt;flags &amp; immutable_access_flag)</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :       o &lt;&lt; &quot;immutable &quot;;</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :     o &lt;&lt; &quot;)\n&quot;;</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     if (!ndo-&gt;tp.is_builtin()) {</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :       o &lt;&lt; &quot;  type-specific arrmeta:\n&quot;;</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :       ndo-&gt;tp-&gt;arrmeta_debug_print(get()-&gt;metadata(), o, indent + &quot;   &quot;);</span>
<span class="lineNum">     885 </span>            :     }
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     o &lt;&lt; &quot; data:\n&quot;;</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :     o &lt;&lt; &quot;   pointer: &quot; &lt;&lt; (void *)ndo-&gt;data &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     o &lt;&lt; &quot;   reference: &quot; &lt;&lt; (void *)ndo-&gt;owner.get();</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     if (!ndo-&gt;owner) {</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :       o &lt;&lt; &quot; (embedded in array memory)\n&quot;;</span>
<span class="lineNum">     891 </span>            :     }
<span class="lineNum">     892 </span>            :     else {
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :       o &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     894 </span>            :     }
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :     if (ndo-&gt;owner) {</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :       memory_block_debug_print(ndo-&gt;owner.get(), o, &quot;    &quot;);</span>
<span class="lineNum">     897 </span>            :     }
<span class="lineNum">     898 </span>            :   }
<span class="lineNum">     899 </span>            :   else {
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     o &lt;&lt; indent &lt;&lt; &quot;NULL\n&quot;;</span>
<span class="lineNum">     901 </span>            :   }
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :   o &lt;&lt; indent &lt;&lt; &quot;------&quot; &lt;&lt; endl;</span>
<a name="903"><span class="lineNum">     903 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineCov">         21 : std::ostream &amp;nd::operator&lt;&lt;(std::ostream &amp;o, const array &amp;rhs)</span>
<span class="lineNum">     906 </span>            : {
<span class="lineNum">     907 </span><span class="lineCov">         21 :   if (!rhs.is_null()) {</span>
<span class="lineNum">     908 </span><span class="lineCov">         21 :     o &lt;&lt; &quot;array(&quot;;</span>
<span class="lineNum">     909 </span><span class="lineCov">         42 :     array v = rhs.eval();</span>
<span class="lineNum">     910 </span><span class="lineCov">         21 :     if (v.get()-&gt;tp.is_builtin()) {</span>
<span class="lineNum">     911 </span><span class="lineCov">         12 :       print_builtin_scalar(v.get()-&gt;tp.get_id(), o, v.get()-&gt;data);</span>
<span class="lineNum">     912 </span>            :     }
<span class="lineNum">     913 </span>            :     else {
<span class="lineNum">     914 </span><span class="lineCov">         18 :       stringstream ss;</span>
<span class="lineNum">     915 </span><span class="lineCov">          9 :       v.get()-&gt;tp-&gt;print_data(ss, v.get()-&gt;metadata(), v.get()-&gt;data);</span>
<span class="lineNum">     916 </span><span class="lineCov">          9 :       print_indented(o, &quot;      &quot;, ss.str(), true);</span>
<span class="lineNum">     917 </span>            :     }
<span class="lineNum">     918 </span><span class="lineCov">         21 :     o &lt;&lt; &quot;,\n      type=\&quot;&quot; &lt;&lt; rhs.get_type() &lt;&lt; &quot;\&quot;)&quot;;</span>
<span class="lineNum">     919 </span>            :   }
<span class="lineNum">     920 </span>            :   else {
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     o &lt;&lt; &quot;array()&quot;;</span>
<span class="lineNum">     922 </span>            :   }
<span class="lineNum">     923 </span><span class="lineCov">         21 :   return o;</span>
<a name="924"><span class="lineNum">     924 </span>            : }</a>
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span><span class="lineCov">          5 : nd::array nd::as_struct(size_t size, const pair&lt;const char *, array&gt; *pairs)</span>
<span class="lineNum">     927 </span>            : {
<span class="lineNum">     928 </span><span class="lineCov">         10 :   std::vector&lt;std::string&gt; names(size);</span>
<span class="lineNum">     929 </span><span class="lineCov">         10 :   std::vector&lt;ndt::type&gt; types(size);</span>
<span class="lineNum">     930 </span><span class="lineCov">         15 :   for (size_t i = 0; i &lt; size; ++i) {</span>
<span class="lineNum">     931 </span><span class="lineCov">         10 :     names[i] = pairs[i].first;</span>
<span class="lineNum">     932 </span><span class="lineCov">         10 :     types[i] = pairs[i].second.get_type();</span>
<span class="lineNum">     933 </span>            :   }
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span><span class="lineCov">          5 :   array res = empty(ndt::struct_type::make(names, types));</span>
<span class="lineNum">     936 </span><span class="lineCov">         15 :   for (size_t i = 0; i &lt; size; ++i) {</span>
<span class="lineNum">     937 </span><span class="lineCov">         10 :     res(i).assign(pairs[i].second);</span>
<span class="lineNum">     938 </span>            :   }
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineCov">         10 :   return res;</span>
<a name="941"><span class="lineNum">     941 </span>            : }</a>
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span><span class="lineCov">       6970 : nd::array nd::empty_shell(const ndt::type &amp;tp)</span>
<span class="lineNum">     944 </span>            : {
<span class="lineNum">     945 </span><span class="lineCov">       6970 :   if (tp.is_builtin()) {</span>
<span class="lineNum">     946 </span><span class="lineCov">       3794 :     char *data_ptr = NULL;</span>
<span class="lineNum">     947 </span>            :     intptr_t data_size =
<span class="lineNum">     948 </span><span class="lineCov">       3794 :         static_cast&lt;intptr_t&gt;(dynd::ndt::detail::builtin_data_sizes[reinterpret_cast&lt;uintptr_t&gt;(tp.extended())]);</span>
<span class="lineNum">     949 </span>            :     intptr_t data_alignment =
<span class="lineNum">     950 </span><span class="lineCov">       3794 :         static_cast&lt;intptr_t&gt;(dynd::ndt::detail::builtin_data_alignments[reinterpret_cast&lt;uintptr_t&gt;(tp.extended())]);</span>
<span class="lineNum">     951 </span><span class="lineCov">       7588 :     intrusive_ptr&lt;memory_block_data&gt; result(make_array_memory_block(0, data_size, data_alignment, &amp;data_ptr));</span>
<span class="lineNum">     952 </span><span class="lineCov">       3794 :     array_preamble *preamble = reinterpret_cast&lt;array_preamble *&gt;(result.get());</span>
<span class="lineNum">     953 </span>            :     // It's a builtin type id, so no incref
<span class="lineNum">     954 </span><span class="lineCov">       3794 :     preamble-&gt;tp = tp;</span>
<span class="lineNum">     955 </span><span class="lineCov">       3794 :     preamble-&gt;data = data_ptr;</span>
<span class="lineNum">     956 </span><span class="lineCov">       3794 :     preamble-&gt;owner = NULL;</span>
<span class="lineNum">     957 </span><span class="lineCov">       3794 :     preamble-&gt;flags = nd::read_access_flag | nd::write_access_flag;</span>
<span class="lineNum">     958 </span><span class="lineCov">       3794 :     return nd::array(preamble, true);</span>
<span class="lineNum">     959 </span>            :   }
<span class="lineNum">     960 </span><span class="lineCov">       3176 :   else if (!tp.is_symbolic()) {</span>
<span class="lineNum">     961 </span><span class="lineCov">       3176 :     char *data_ptr = NULL;</span>
<span class="lineNum">     962 </span><span class="lineCov">       3176 :     size_t arrmeta_size = tp.extended()-&gt;get_arrmeta_size();</span>
<span class="lineNum">     963 </span><span class="lineCov">       3176 :     size_t data_size = tp.extended()-&gt;get_default_data_size();</span>
<span class="lineNum">     964 </span><span class="lineCov">       6352 :     intrusive_ptr&lt;memory_block_data&gt; result;</span>
<span class="lineNum">     965 </span><span class="lineCov">       3176 :     if (tp.get_kind() != memory_kind) {</span>
<span class="lineNum">     966 </span>            :       // Allocate memory the default way
<span class="lineNum">     967 </span><span class="lineCov">       3176 :       result = make_array_memory_block(arrmeta_size, data_size, tp.get_data_alignment(), &amp;data_ptr);</span>
<span class="lineNum">     968 </span><span class="lineCov">       3176 :       if (tp.get_flags() &amp; type_flag_zeroinit) {</span>
<span class="lineNum">     969 </span><span class="lineCov">       2100 :         memset(data_ptr, 0, data_size);</span>
<span class="lineNum">     970 </span>            :       }
<span class="lineNum">     971 </span><span class="lineCov">       3176 :       if (tp.get_flags() &amp; type_flag_construct) {</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :         tp.extended()-&gt;data_construct(NULL, data_ptr);</span>
<span class="lineNum">     973 </span>            :       }
<span class="lineNum">     974 </span>            :     }
<span class="lineNum">     975 </span>            :     else {
<span class="lineNum">     976 </span>            :       // Allocate memory based on the memory_kind type
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :       result = make_array_memory_block(arrmeta_size);</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :       tp.extended&lt;ndt::base_memory_type&gt;()-&gt;data_alloc(&amp;data_ptr, data_size);</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :       if (tp.get_flags() &amp; type_flag_zeroinit) {</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :         tp.extended&lt;ndt::base_memory_type&gt;()-&gt;data_zeroinit(data_ptr, data_size);</span>
<span class="lineNum">     981 </span>            :       }
<span class="lineNum">     982 </span>            :     }
<span class="lineNum">     983 </span><span class="lineCov">       3176 :     array_preamble *preamble = reinterpret_cast&lt;array_preamble *&gt;(result.get());</span>
<span class="lineNum">     984 </span><span class="lineCov">       3176 :     preamble-&gt;tp = tp;</span>
<span class="lineNum">     985 </span><span class="lineCov">       3176 :     preamble-&gt;data = data_ptr;</span>
<span class="lineNum">     986 </span><span class="lineCov">       3176 :     preamble-&gt;owner = NULL;</span>
<span class="lineNum">     987 </span><span class="lineCov">       3176 :     preamble-&gt;flags = nd::read_access_flag | nd::write_access_flag;</span>
<span class="lineNum">     988 </span><span class="lineCov">       3176 :     return nd::array(preamble, true);</span>
<span class="lineNum">     989 </span>            :   }
<span class="lineNum">     990 </span>            :   else {
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :     stringstream ss;</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :     ss &lt;&lt; &quot;Cannot create a dynd array with symbolic type &quot; &lt;&lt; tp;</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :     throw type_error(ss.str());</span>
<span class="lineNum">     994 </span>            :   }
<a name="995"><span class="lineNum">     995 </span>            : }</a>
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span><span class="lineCov">       6970 : nd::array nd::empty(const ndt::type &amp;tp)</span>
<span class="lineNum">     998 </span>            : {
<span class="lineNum">     999 </span>            :   // Create an empty shell
<span class="lineNum">    1000 </span><span class="lineCov">       6970 :   nd::array res = nd::empty_shell(tp);</span>
<span class="lineNum">    1001 </span>            :   // Construct the arrmeta with default settings
<span class="lineNum">    1002 </span><span class="lineCov">       6970 :   if (tp.get_arrmeta_size() &gt; 0) {</span>
<span class="lineNum">    1003 </span><span class="lineCov">       1027 :     array_preamble *preamble = res.get();</span>
<span class="lineNum">    1004 </span><span class="lineCov">       1027 :     preamble-&gt;tp-&gt;arrmeta_default_construct(reinterpret_cast&lt;char *&gt;(preamble + 1), true);</span>
<span class="lineNum">    1005 </span>            :   }
<span class="lineNum">    1006 </span><span class="lineCov">       6970 :   return res;</span>
<a name="1007"><span class="lineNum">    1007 </span>            : }</a>
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 : nd::array nd::empty_like(const nd::array &amp;rhs, const ndt::type &amp;uniform_tp)</span>
<span class="lineNum">    1010 </span>            : {
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   if (rhs.get_ndim() == 0) {</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     return nd::empty(uniform_tp);</span>
<span class="lineNum">    1013 </span>            :   }
<span class="lineNum">    1014 </span>            :   else {
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     size_t ndim = rhs.get_type().extended()-&gt;get_ndim();</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     dimvector shape(ndim);</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     rhs.get_shape(shape.get());</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     array result = empty(make_fixed_dim(ndim, shape.get(), uniform_tp));</span>
<span class="lineNum">    1019 </span>            :     // Reorder strides of output strided dimensions in a KEEPORDER fashion
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     if (result.get_type().get_id() == fixed_dim_id) {</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :       result.get_type().extended&lt;ndt::fixed_dim_type&gt;()-&gt;reorder_default_constructed_strides(</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :           result.get()-&gt;metadata(), rhs.get_type(), rhs.get()-&gt;metadata());</span>
<span class="lineNum">    1023 </span>            :     }
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">    1025 </span>            :   }
<a name="1026"><span class="lineNum">    1026 </span>            : }</a>
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 : nd::array nd::empty_like(const nd::array &amp;rhs)</span>
<span class="lineNum">    1029 </span>            : {
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   ndt::type dt;</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   if (rhs.get()-&gt;tp.is_builtin()) {</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :     dt = ndt::type(rhs.get()-&gt;tp.get_id());</span>
<span class="lineNum">    1033 </span>            :   }
<span class="lineNum">    1034 </span>            :   else {
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     dt = rhs.get()-&gt;tp-&gt;get_canonical_type();</span>
<span class="lineNum">    1036 </span>            :   }
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :   if (rhs.is_scalar()) {</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     return nd::empty(dt);</span>
<span class="lineNum">    1040 </span>            :   }
<span class="lineNum">    1041 </span>            :   else {
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :     intptr_t ndim = dt.extended()-&gt;get_ndim();</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :     dimvector shape(ndim);</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :     rhs.get_shape(shape.get());</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :     nd::array result = empty(make_fixed_dim(ndim, shape.get(), dt.get_dtype()));</span>
<span class="lineNum">    1046 </span>            :     // Reorder strides of output strided dimensions in a KEEPORDER fashion
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :     if (result.get_type().get_id() == fixed_dim_id) {</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :       result.get_type().extended&lt;ndt::fixed_dim_type&gt;()-&gt;reorder_default_constructed_strides(</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :           result.get()-&gt;metadata(), rhs.get_type(), rhs.get()-&gt;metadata());</span>
<span class="lineNum">    1050 </span>            :     }
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">    1052 </span>            :   }
<a name="1053"><span class="lineNum">    1053 </span>            : }</a>
<span class="lineNum">    1054 </span>            : 
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 : nd::array nd::concatenate(const nd::array &amp;x, const nd::array &amp;y)</span>
<span class="lineNum">    1056 </span>            : {
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :   if (x.get_ndim() != 1 || y.get_ndim() != 1) {</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :     throw runtime_error(&quot;TODO: nd::concatenate is WIP&quot;);</span>
<span class="lineNum">    1059 </span>            :   }
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :   if (x.get_dtype() != y.get_dtype()) {</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :     throw runtime_error(&quot;dtypes must be the same for concatenate&quot;);</span>
<span class="lineNum">    1063 </span>            :   }
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :   nd::array res = nd::empty(x.get_dim_size() + y.get_dim_size(), x.get_dtype());</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :   res(irange(0, x.get_dim_size())).assign(x);</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :   res(irange(x.get_dim_size(), res.get_dim_size())).assign(y);</span>
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :   return res;</span>
<a name="1070"><span class="lineNum">    1070 </span>            : }</a>
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span><span class="lineCov">         12 : nd::array nd::reshape(const nd::array &amp;a, const nd::array &amp;shape)</span>
<span class="lineNum">    1073 </span>            : {
<span class="lineNum">    1074 </span><span class="lineCov">         12 :   intptr_t ndim = shape.get_dim_size();</span>
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span><span class="lineCov">         12 :   intptr_t old_ndim = a.get_ndim();</span>
<span class="lineNum">    1077 </span><span class="lineCov">         24 :   dimvector old_shape(old_ndim);</span>
<span class="lineNum">    1078 </span><span class="lineCov">         12 :   a.get_shape(old_shape.get());</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span><span class="lineCov">         12 :   intptr_t old_size = 1;</span>
<span class="lineNum">    1081 </span><span class="lineCov">         33 :   for (intptr_t i = 0; i &lt; old_ndim; ++i) {</span>
<span class="lineNum">    1082 </span><span class="lineCov">         21 :     old_size *= old_shape[i];</span>
<span class="lineNum">    1083 </span>            :   }
<span class="lineNum">    1084 </span><span class="lineCov">         12 :   intptr_t size = 1;</span>
<span class="lineNum">    1085 </span><span class="lineCov">         33 :   for (intptr_t i = 0; i &lt; ndim; ++i) {</span>
<span class="lineNum">    1086 </span><span class="lineCov">         21 :     size *= shape(i).as&lt;intptr_t&gt;();</span>
<span class="lineNum">    1087 </span>            :   }
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span><span class="lineCov">         12 :   if (old_size != size) {</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :     stringstream ss;</span>
<span class="lineNum">    1091 </span>            :     ss &lt;&lt; &quot;dynd reshape: cannot reshape to a different total number of &quot;
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :           &quot;elements, from &quot;</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :        &lt;&lt; old_size &lt;&lt; &quot; to &quot; &lt;&lt; size;</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :     throw invalid_argument(ss.str());</span>
<span class="lineNum">    1095 </span>            :   }
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span><span class="lineCov">         24 :   dimvector strides(ndim);</span>
<span class="lineNum">    1098 </span><span class="lineCov">         12 :   strides[ndim - 1] = a.get_dtype().get_data_size();</span>
<span class="lineNum">    1099 </span><span class="lineCov">         21 :   for (intptr_t i = ndim - 2; i &gt;= 0; --i) {</span>
<span class="lineNum">    1100 </span><span class="lineCov">          9 :     strides[i] = shape(i + 1).as&lt;intptr_t&gt;() * strides[i + 1];</span>
<span class="lineNum">    1101 </span>            :   }
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span><span class="lineCov">         24 :   dimvector shape_copy(ndim);</span>
<span class="lineNum">    1104 </span><span class="lineCov">         33 :   for (intptr_t i = 0; i &lt; ndim; ++i) {</span>
<span class="lineNum">    1105 </span><span class="lineCov">         21 :     shape_copy[i] = shape(i).as&lt;intptr_t&gt;();</span>
<span class="lineNum">    1106 </span>            :   }
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span><span class="lineCov">         36 :   return make_strided_array_from_data(a.get_dtype(), ndim, shape_copy.get(), strides.get(), a.get_flags(), a.data(),</span>
<span class="lineNum">    1109 </span><span class="lineCov">         60 :                                       intrusive_ptr&lt;memory_block_data&gt;(a.get(), true), NULL);</span>
<a name="1110"><span class="lineNum">    1110 </span>            : }</a>
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 : nd::array nd::memmap(const std::string &amp;DYND_UNUSED(filename), intptr_t DYND_UNUSED(begin), intptr_t DYND_UNUSED(end),</span>
<span class="lineNum">    1113 </span>            :                      uint32_t DYND_UNUSED(access))
<span class="lineNum">    1114 </span>            : {
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :   throw std::runtime_error(&quot;nd::memmap is not yet implemented&quot;);</span>
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span>            :   /*
<span class="lineNum">    1118 </span>            :     // ToDo: This was based on the variable-sized bytes type, which changed.
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            :     if (access == 0) {
<span class="lineNum">    1121 </span>            :       access = nd::default_access_flags;
<span class="lineNum">    1122 </span>            :     }
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span>            :     char *mm_ptr = NULL;
<span class="lineNum">    1125 </span>            :     intptr_t mm_size = 0;
<span class="lineNum">    1126 </span>            :     // Create a memory mapped memblock of the file
<span class="lineNum">    1127 </span>            :     intrusive_ptr&lt;memory_block_data&gt; mm = make_memmap_memory_block(filename, access, &amp;mm_ptr, &amp;mm_size, begin, end);
<span class="lineNum">    1128 </span>            :     // Create a bytes array referring to the data.
<span class="lineNum">    1129 </span>            :     ndt::type dt = ndt::bytes_type::make(1);
<span class="lineNum">    1130 </span>            :     char *data_ptr = 0;
<span class="lineNum">    1131 </span>            :     nd::array result(make_array_memory_block(dt.extended()-&gt;get_arrmeta_size(), dt.get_data_size(),
<span class="lineNum">    1132 </span>            :                                              dt.get_data_alignment(), &amp;data_ptr));
<span class="lineNum">    1133 </span>            :     // Set the bytes extents
<span class="lineNum">    1134 </span>            :     reinterpret_cast&lt;bytes *&gt;(data_ptr)-&gt;assign(mm_ptr, mm_size);
<span class="lineNum">    1135 </span>            :     // Set the array arrmeta
<span class="lineNum">    1136 </span>            :     array_preamble *ndo = result.get();
<span class="lineNum">    1137 </span>            :     ndo-&gt;tp = dt.release();
<span class="lineNum">    1138 </span>            :     ndo-&gt;data = data_ptr;
<span class="lineNum">    1139 </span>            :     ndo-&gt;owner = NULL;
<span class="lineNum">    1140 </span>            :     ndo-&gt;flags = access;
<span class="lineNum">    1141 </span>            :     // Set the bytes arrmeta, telling the system
<span class="lineNum">    1142 </span>            :     // about the memmapped memblock
<span class="lineNum">    1143 </span>            :     ndo_meta-&gt;blockref = mm.release();
<span class="lineNum">    1144 </span>            :     return result;
<span class="lineNum">    1145 </span>            :   */
<a name="1146"><span class="lineNum">    1146 </span>            : }</a>
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span><span class="lineCov">          1 : nd::array nd::combine_into_tuple(size_t field_count, const array *field_values)</span>
<span class="lineNum">    1149 </span>            : {
<span class="lineNum">    1150 </span>            :   // Make the pointer types
<span class="lineNum">    1151 </span><span class="lineCov">          2 :   vector&lt;ndt::type&gt; field_types(field_count);</span>
<span class="lineNum">    1152 </span><span class="lineCov">          2 :   for (size_t i = 0; i != field_count; ++i) {</span>
<span class="lineNum">    1153 </span><span class="lineCov">          1 :     field_types[i] = ndt::pointer_type::make(field_values[i].get_type());</span>
<span class="lineNum">    1154 </span>            :   }
<span class="lineNum">    1155 </span>            :   // The flags are the intersection of all the input flags
<span class="lineNum">    1156 </span><span class="lineCov">          1 :   uint64_t flags = field_values[0].get_flags();</span>
<span class="lineNum">    1157 </span><span class="lineCov">          1 :   for (size_t i = 1; i != field_count; ++i) {</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :     flags &amp;= field_values[i].get_flags();</span>
<span class="lineNum">    1159 </span>            :   }
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span><span class="lineCov">          2 :   ndt::type result_type = ndt::tuple_type::make(field_types);</span>
<span class="lineNum">    1162 </span><span class="lineCov">          1 :   const ndt::tuple_type *fsd = result_type.extended&lt;ndt::tuple_type&gt;();</span>
<span class="lineNum">    1163 </span><span class="lineCov">          1 :   char *data_ptr = NULL;</span>
<span class="lineNum">    1164 </span>            : 
<span class="lineNum">    1165 </span>            :   array result(
<span class="lineNum">    1166 </span><span class="lineCov">          2 :       reinterpret_cast&lt;array_preamble *&gt;(make_array_memory_block(fsd-&gt;get_arrmeta_size(), fsd-&gt;get_default_data_size(),</span>
<span class="lineNum">    1167 </span>            :                                                                  fsd-&gt;get_data_alignment(), &amp;data_ptr)
<span class="lineNum">    1168 </span><span class="lineCov">          1 :                                              .get()),</span>
<span class="lineNum">    1169 </span><span class="lineCov">          1 :       true);</span>
<span class="lineNum">    1170 </span>            :   // Set the array properties
<span class="lineNum">    1171 </span><span class="lineCov">          1 :   result.get()-&gt;tp = result_type;</span>
<span class="lineNum">    1172 </span><span class="lineCov">          1 :   result.get()-&gt;data = data_ptr;</span>
<span class="lineNum">    1173 </span><span class="lineCov">          1 :   result.get()-&gt;owner = NULL;</span>
<span class="lineNum">    1174 </span><span class="lineCov">          1 :   result.get()-&gt;flags = flags;</span>
<span class="lineNum">    1175 </span>            : 
<span class="lineNum">    1176 </span>            :   // Set the data offsets arrmeta for the tuple type. It's a bunch of pointer
<span class="lineNum">    1177 </span>            :   // types, so the offsets are pretty simple.
<span class="lineNum">    1178 </span><span class="lineCov">          1 :   intptr_t *data_offsets = reinterpret_cast&lt;intptr_t *&gt;(result.get()-&gt;metadata());</span>
<span class="lineNum">    1179 </span><span class="lineCov">          2 :   for (size_t i = 0; i != field_count; ++i) {</span>
<span class="lineNum">    1180 </span><span class="lineCov">          1 :     data_offsets[i] = i * sizeof(void *);</span>
<span class="lineNum">    1181 </span>            :   }
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span>            :   // Copy all the needed arrmeta
<span class="lineNum">    1184 </span><span class="lineCov">          1 :   const std::vector&lt;uintptr_t&gt; &amp;arrmeta_offsets = fsd-&gt;get_arrmeta_offsets();</span>
<span class="lineNum">    1185 </span><span class="lineCov">          2 :   for (size_t i = 0; i != field_count; ++i) {</span>
<span class="lineNum">    1186 </span>            :     pointer_type_arrmeta *pmeta;
<span class="lineNum">    1187 </span><span class="lineCov">          1 :     pmeta = reinterpret_cast&lt;pointer_type_arrmeta *&gt;(result.get()-&gt;metadata() + arrmeta_offsets[i]);</span>
<span class="lineNum">    1188 </span><span class="lineCov">          1 :     pmeta-&gt;offset = 0;</span>
<span class="lineNum">    1189 </span><span class="lineCov">          4 :     pmeta-&gt;blockref = field_values[i].get()-&gt;owner ? field_values[i].get()-&gt;owner</span>
<span class="lineNum">    1190 </span><span class="lineCov">          3 :                                                    : intrusive_ptr&lt;memory_block_data&gt;(field_values[i].get(), true);</span>
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span><span class="lineCov">          1 :     const ndt::type &amp;field_dt = field_values[i].get_type();</span>
<span class="lineNum">    1193 </span><span class="lineCov">          1 :     if (field_dt.get_arrmeta_size() &gt; 0) {</span>
<span class="lineNum">    1194 </span><span class="lineCov">          4 :       field_dt.extended()-&gt;arrmeta_copy_construct(reinterpret_cast&lt;char *&gt;(pmeta + 1),</span>
<span class="lineNum">    1195 </span><span class="lineCov">          1 :                                                   field_values[i].get()-&gt;metadata(),</span>
<span class="lineNum">    1196 </span><span class="lineCov">          2 :                                                   intrusive_ptr&lt;memory_block_data&gt;(field_values[i].get(), true));</span>
<span class="lineNum">    1197 </span>            :     }
<span class="lineNum">    1198 </span>            :   }
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            :   // Set the data pointers
<span class="lineNum">    1201 </span><span class="lineCov">          1 :   const char **dp = reinterpret_cast&lt;const char **&gt;(data_ptr);</span>
<span class="lineNum">    1202 </span><span class="lineCov">          2 :   for (size_t i = 0; i != field_count; ++i) {</span>
<span class="lineNum">    1203 </span><span class="lineCov">          1 :     dp[i] = field_values[i].cdata();</span>
<a name="1204"><span class="lineNum">    1204 </span>            :   }</a>
<span class="lineNum">    1205 </span><span class="lineCov">          2 :   return result;</span>
<span class="lineNum">    1206 </span><span class="lineCov">          3 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
